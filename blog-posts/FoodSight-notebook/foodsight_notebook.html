<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>FoodSight</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="foodsight_notebook_files/libs/clipboard/clipboard.min.js"></script>
<script src="foodsight_notebook_files/libs/quarto-html/quarto.js"></script>
<script src="foodsight_notebook_files/libs/quarto-html/popper.min.js"></script>
<script src="foodsight_notebook_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="foodsight_notebook_files/libs/quarto-html/anchor.min.js"></script>
<link href="foodsight_notebook_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="foodsight_notebook_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="foodsight_notebook_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="foodsight_notebook_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="foodsight_notebook_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents:</h2>
   
  <ul>
  <li><a href="#section" id="toc-section" class="nav-link active" data-scroll-target="#section"></a></li>
  <li><a href="#section-1" id="toc-section-1" class="nav-link" data-scroll-target="#section-1"></a>
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#web-application" id="toc-web-application" class="nav-link" data-scroll-target="#web-application">Web application</a>
  <ul>
  <li><a href="#forecast-page" id="toc-forecast-page" class="nav-link" data-scroll-target="#forecast-page">Forecast page</a></li>
  <li><a href="#markets-page" id="toc-markets-page" class="nav-link" data-scroll-target="#markets-page">Markets page</a></li>
  <li><a href="#decision-support-tool-page" id="toc-decision-support-tool-page" class="nav-link" data-scroll-target="#decision-support-tool-page">Decision Support Tool page</a></li>
  <li><a href="#third-party-dependencies" id="toc-third-party-dependencies" class="nav-link" data-scroll-target="#third-party-dependencies">Third party dependencies</a></li>
  </ul></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a>
  <ul>
  <li><a href="#grasscast-and-related-data" id="toc-grasscast-and-related-data" class="nav-link" data-scroll-target="#grasscast-and-related-data">GrassCast and related data</a>
  <ul>
  <li><a href="#spatial-data" id="toc-spatial-data" class="nav-link" data-scroll-target="#spatial-data">Spatial data</a>
  <ul class="collapse">
  <li><a href="#grasscast-grid" id="toc-grasscast-grid" class="nav-link" data-scroll-target="#grasscast-grid">Grasscast Grid</a>
  <ul class="collapse">
  <li><a href="#select-grid-cells-of-interest" id="toc-select-grid-cells-of-interest" class="nav-link" data-scroll-target="#select-grid-cells-of-interest">Select grid cells of interest</a></li>
  <li><a href="#south-west-cells" id="toc-south-west-cells" class="nav-link" data-scroll-target="#south-west-cells">South West cells</a></li>
  <li><a href="#great-plains-cells" id="toc-great-plains-cells" class="nav-link" data-scroll-target="#great-plains-cells">Great Plains cells</a></li>
  <li><a href="#overlaping-cells" id="toc-overlaping-cells" class="nav-link" data-scroll-target="#overlaping-cells">Overlaping cells</a></li>
  <li><a href="#combining-both-regions" id="toc-combining-both-regions" class="nav-link" data-scroll-target="#combining-both-regions">Combining both regions</a></li>
  <li><a href="#list-grid-cells-by-aoi" id="toc-list-grid-cells-by-aoi" class="nav-link" data-scroll-target="#list-grid-cells-by-aoi">List grid cells by AOI</a></li>
  </ul></li>
  <li><a href="#counties" id="toc-counties" class="nav-link" data-scroll-target="#counties">Counties</a></li>
  </ul></li>
  <li><a href="#grasscast-data" id="toc-grasscast-data" class="nav-link" data-scroll-target="#grasscast-data">Grasscast Data</a>
  <ul class="collapse">
  <li><a href="#forecast-data" id="toc-forecast-data" class="nav-link" data-scroll-target="#forecast-data">Forecast Data</a>
  <ul class="collapse">
  <li><a href="#great-plains" id="toc-great-plains" class="nav-link" data-scroll-target="#great-plains">Great Plains</a></li>
  <li><a href="#southwest" id="toc-southwest" class="nav-link" data-scroll-target="#southwest">Southwest</a></li>
  </ul></li>
  <li><a href="#historic-data" id="toc-historic-data" class="nav-link" data-scroll-target="#historic-data">Historic Data</a>
  <ul class="collapse">
  <li><a href="#great-plains-1" id="toc-great-plains-1" class="nav-link" data-scroll-target="#great-plains-1">Great Plains</a></li>
  <li><a href="#southwest-1" id="toc-southwest-1" class="nav-link" data-scroll-target="#southwest-1">Southwest</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#climate-data-forecast-corrections" id="toc-climate-data-forecast-corrections" class="nav-link" data-scroll-target="#climate-data-forecast-corrections">Climate data &amp; forecast corrections</a>
  <ul class="collapse">
  <li><a href="#incorporate-climate-outlooks-to-grasscast-grid" id="toc-incorporate-climate-outlooks-to-grasscast-grid" class="nav-link" data-scroll-target="#incorporate-climate-outlooks-to-grasscast-grid">Incorporate Climate Outlooks to Grasscast grid</a></li>
  <li><a href="#southwest-2" id="toc-southwest-2" class="nav-link" data-scroll-target="#southwest-2">Southwest</a></li>
  <li><a href="#great-plains-2" id="toc-great-plains-2" class="nav-link" data-scroll-target="#great-plains-2">Great Plains</a></li>
  <li><a href="#combining-sw-and-gp-data" id="toc-combining-sw-and-gp-data" class="nav-link" data-scroll-target="#combining-sw-and-gp-data">Combining SW and GP data</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#market-data" id="toc-market-data" class="nav-link" data-scroll-target="#market-data">Market data</a>
  <ul>
  <li><a href="#mymarketnews-api-exploration" id="toc-mymarketnews-api-exploration" class="nav-link" data-scroll-target="#mymarketnews-api-exploration">MyMarketNews API exploration</a></li>
  <li><a href="#listing-available-markets-for-cattle-and-hay" id="toc-listing-available-markets-for-cattle-and-hay" class="nav-link" data-scroll-target="#listing-available-markets-for-cattle-and-hay">Listing available markets for Cattle and Hay</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#lambda-functions" id="toc-lambda-functions" class="nav-link" data-scroll-target="#lambda-functions">Lambda Functions</a>
  <ul>
  <li><a href="#forecast-data-updates" id="toc-forecast-data-updates" class="nav-link" data-scroll-target="#forecast-data-updates">Forecast Data Updates</a>
  <ul>
  <li><a href="#climate-lambda-function" id="toc-climate-lambda-function" class="nav-link" data-scroll-target="#climate-lambda-function">Climate Lambda Function</a></li>
  <li><a href="#forecast-lambda-function" id="toc-forecast-lambda-function" class="nav-link" data-scroll-target="#forecast-lambda-function">Forecast Lambda Function</a></li>
  </ul></li>
  <li><a href="#market-data-updates" id="toc-market-data-updates" class="nav-link" data-scroll-target="#market-data-updates">Market Data Updates</a></li>
  </ul></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a>
  <ul>
  <li><a href="#productivity-forecast" id="toc-productivity-forecast" class="nav-link" data-scroll-target="#productivity-forecast">Productivity Forecast</a></li>
  <li><a href="#market-data-1" id="toc-market-data-1" class="nav-link" data-scroll-target="#market-data-1">Market Data</a></li>
  <li><a href="#decision-support-tool" id="toc-decision-support-tool" class="nav-link" data-scroll-target="#decision-support-tool">Decision Support Tool</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">FoodSight</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="section" class="level1">
<h1></h1>
</section>
<section id="section-1" class="level1">
<h1></h1>
<p>This project focuses on providing non-experts in data analysis with easy access to farming and ranching data. It offers a user-friendly tool to engage with dynamic and interactive outputs from the GrassCast Aboveground Net Primary Productivity (ANPP) model, a collaborative effort between the University of Nebraska–Lincoln, USDA, NDMC, Colorado State University, and the University of Arizona. Although static maps and CSV files from this model are available at <a href="https://grasscast.unl.edu/">https://grasscast.unl.edu/</a>, their complexity can be challenging for general audiences. Our web application simplifies access, visualization, and interpretation of this data, and includes basic spatial analysis tools for insights into expected productivity for each growing season.</p>
<p>Moreover, the application integrates GrassCast scenarios with Climate Outlooks from the Climate Prediction Center of the National Weather Service, available at <a href="https://www.cpc.ncep.noaa.gov/products/predictions/long_range/interactive/index.php">https://www.cpc.ncep.noaa.gov/products/predictions/long_range/interactive/index.php</a>. This feature enhances the understanding of likely scenarios.</p>
<p>Additionally, the application has sections dedicated to ranching and farming market data, sourced from the My Market News USDA API. This allows users to directly access and analyze market data and trends for Cattle and Hay commodities, across all US auctions. Furthermore, the application includes a decision-making tool developed by Colorado State University, particularly useful during drought conditions.</p>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>For constructing the applications, we utilized AWS services including ElasticBeanstalk, Lambda, S3, and EC2 instances. The backend code is designed to automate data retrieval through API integrations and web scraping. These services are employed to store, update, and process data for display in an interactive application, which is hosted at <a href="https://app.foodsight.org/">https://app.foodsight.org/</a>. The diagram below presents an overview of the architectural structure designed around the application, ensuring the provision of updated and interactive information.</p>
<div class="cell" data-execution_count="2">
<div class="cell-output cell-output-display" data-execution_count="2">
<p><img src="foodsight_notebook_files/figure-html/cell-3-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The following sections will explain in more detail the data used, as well as the acquisition and processing techniques implemented.</p>
</section>
<section id="web-application" class="level2">
<h2 class="anchored" data-anchor-id="web-application">Web application</h2>
<p>Developed using Python’s Dash framework, FoodSight offers an interactive and user-friendly interface, allowing users to explore grasslands productivity forecast and cattle market data.</p>
<p>Python Dash, known for its simplicity and efficiency, forms the backbone of FoodSight’s back and front end code. Dash framework enables the seamless integration of Python’s robust data processing capabilities with modern web technologies, creating a dynamic and responsive user experience. Dash’s ability to handle complex data visualizations and real-time updates makes it the ideal choice for FoodSight.</p>
<p>The deployment of the app on AWS Elastic Beanstalk further enhances its accessibility and scalability. Elastic Beanstalk, a service provided by Amazon Web Services (AWS), offers an easy-to-use platform for deploying and managing web applications. By leveraging Elastic Beanstalk, FoodSight benefits of automatic scaling, load balancing, and health monitoring, ensuring that the application remains robust and responsive.</p>
<p>The application’s code and dependencies associated with Elastic Beanstalk deployment can be found in the “foodsight-app” folder within this repository. Though the core element of the application is the interactive display of ANPP forecast data, the application also contains two additional main pages, one for market data and another for a decision-making tool.</p>
<section id="forecast-page" class="level3">
<h3 class="anchored" data-anchor-id="forecast-page">Forecast page</h3>
<p>This section presents the Grassland Productivity Forecast generated by Grasscast from the National Drought Mitigation Center at the University of Nebraska-Lincoln. The forecast is summarized based on county or map selection. Expected production is correlated with anticipated climate scenarios from the NOAA Climate Prediction Center. Users can access the most recent forecast value released and track forecast trends until the end of each season. Additionally, one can navigate through historical data to view past productivity. The platform also enables users to spatially identify areas with higher productivity in comparison to a current location or a selected location on the map. This feature is particularly useful for exploring productivity across the southwest plains. Ranchers and land managers should use this information in combination with their local knowledge of soils, plant communities, topography, and management to help with decision-making.</p>
<p><img src="img/forecast_page.png" class="img-fluid"></p>
</section>
<section id="markets-page" class="level3">
<h3 class="anchored" data-anchor-id="markets-page">Markets page</h3>
<p>This section provides access to nominal data from several cattle and hay market auctions. The data is sourced from the MyMarketNews API, a USDA service that offers unbiased, timely, and accurate market information for hundreds of agricultural commodities and their related products. This interface features multiple tabs, enabling users to select a specific time range, cattle or hay type, state, and auction market. For cattle, users can choose between viewing daily average prices or monthly aggregated prices. Furthermore, users can visualize the relationship between prices and weight based on the most recent auction data. For hay, the platform showcases daily average price trends across various markets.</p>
<p><img src="img/markets_page.png" class="img-fluid"></p>
</section>
<section id="decision-support-tool-page" class="level3">
<h3 class="anchored" data-anchor-id="decision-support-tool-page">Decision Support Tool page</h3>
<p>This section integrates the ‘Strategies for Beef Cattle Herds During Times of Drought,’ designed by Jeffrey E. Tranel, Rod Sharp, &amp; John Deering from the Department of Agriculture and Business Management at Colorado State University. This decision tool aims to assist cow-calf producers in comparing the financial implications of various management strategies during droughts when grazing forage becomes scarce. It serves as a guide only. Producers should consult with their lenders, tax practitioners, and/or other professionals before making any final decisions.</p>
<p><img src="img/tool_page.png" class="img-fluid"></p>
</section>
<section id="third-party-dependencies" class="level3">
<h3 class="anchored" data-anchor-id="third-party-dependencies">Third party dependencies</h3>
<p>The application framework requires services provided by third parties, for which a user account is needed. Specifically, the application makes calls to access these services using personal tokens that are not included in this repository. As seen in the app code and throughout this document, such accounts are:</p>
<ul>
<li><p>Mapbox: The forecast sections of the map require a Mapbox token, which can be obtained by creating a free account at <a href="https://www.mapbox.com/">https://www.mapbox.com/</a>. Store this token in the .mapbox_token variable within the app.</p></li>
<li><p>MyMarketNews API: All market data is provided by a USDA API, which also requires a user account and authentication using a token. Store this token in the .mmn_api_token variable within the code. You can create a free account at <a href="https://mymarketnews.ams.usda.gov/mymarketnews-api/">https://mymarketnews.ams.usda.gov/mymarketnews-api/</a>.</p></li>
<li><p>AWS: The entire architectural structure of the app is deployed using Amazon Web Services (AWS), which also requires an account and authentication. Running this code on AWS may incur costs, so please be aware of this if you decide to implement it on your own.</p></li>
</ul>
</section>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>There are three main sources of data used in the application. This includes the data related to grassland productivity derived from GrassCast and NOAA, as well as the market data extracted from USDA My Market News API. Next, we will go through these two groups of data and the processing conducted to feed the app.</p>
<section id="grasscast-and-related-data" class="level3">
<h3 class="anchored" data-anchor-id="grasscast-and-related-data">GrassCast and related data</h3>
<p>The forecast data is available in two distinct forms: the most recent biweekly forecast values for each season and the time series with historical productivity values. For the former, the forecast outputs include three possible scenarios, which need to be correlated with the NOAA Climate Outlooks, another dataset considered in the data processing. Lastly, all GrassCast data has a spatial component, where forecast values are assigned to a grid of 10km x 10km cells. Each cell is assigned an ID corresponding to a polygon on a geofile and to an observation in the historical and forecast GrassCast datasets. Here, we will detail the data processing required to prepare the data to be read by the application.</p>
<section id="spatial-data" class="level4">
<h4 class="anchored" data-anchor-id="spatial-data">Spatial data</h4>
<p>Each GrassCast dataset is associated with a grid, with each row identified by an cell ID. The original grid for the entire USA was obtained from USDA in shapefile format. In the following lines, we will extract the cells of interest for the Great Plains (GP) and Southwest (SW) regions. Further, the application considers data summaries based on county location, which were processed based on GrassCast grid extension.</p>
<section id="grasscast-grid" class="level5">
<h5 class="anchored" data-anchor-id="grasscast-grid">Grasscast Grid</h5>
<section id="select-grid-cells-of-interest" class="level6">
<h6 class="anchored" data-anchor-id="select-grid-cells-of-interest">Select grid cells of interest</h6>
<p>The following code chunks include the workflow to select the grid cells of interest from the USDA grid shapefile. This is selecting the cells corresponding to the GP and SW, from the USDA grid containing all the USA continental territory (original_grid).</p>
<p>Due to a disparity in grid size between the historic and forecast datasets—the historic data contains some additional grid cell compared to the forecast dataset—we will proceed with the ids from the dataset that has a higher number of cells to extract the grid of interest from the “original_grid.”</p>
<div class="cell" data-execution_count="80">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Read original grid .shp from USDA</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>shapefile_path <span class="op">=</span> <span class="st">'../testing_data/aws/spatial_data/raw/RAW-grid_10km_x_10km_fips/grid_10km_x_10km_fips.shp'</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>original_grid <span class="op">=</span> gpd.read_file(shapefile_path)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="south-west-cells" class="level6">
<h6 class="anchored" data-anchor-id="south-west-cells">South West cells</h6>
<div class="cell" data-execution_count="87">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>hist_grasscast_sw <span class="op">=</span> pd.read_csv(<span class="st">"../testing_data/aws/sw/hist_data_grasscast_sw.csv"</span>).clean_names()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Getting unique cell_ids as a Series</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>cell_ids_series <span class="op">=</span> pd.Series(hist_grasscast_sw[<span class="st">'gridid'</span>].unique(), name<span class="op">=</span><span class="st">'gridid'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Join csv data to the shapefile by 'Id' and 'gridid' fields respectively</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>joined_data <span class="op">=</span> original_grid.merge(cell_ids_series.to_frame(), left_on<span class="op">=</span><span class="st">'Id'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>joined_data.drop(<span class="st">'gridid'</span>, axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Additionally, it is necessary to redefine the Coordinate Reference System (CRS) as both Folium and Plotly require the ‘epsg:4326’ CRS.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>joined_data <span class="op">=</span> joined_data.rename(columns<span class="op">=</span>{<span class="st">'Id'</span>: <span class="st">'gridid'</span>})</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>joined_data <span class="op">=</span> joined_data.to_crs(epsg<span class="op">=</span><span class="dv">4326</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To avoid repeating the extraction process and enable easy access to the spatial data, we will save the grid of interest.</p>
</section>
<section id="great-plains-cells" class="level6">
<h6 class="anchored" data-anchor-id="great-plains-cells">Great Plains cells</h6>
<p>We will apply the same proceeding with the GP grid ids.</p>
<div class="cell" data-execution_count="85">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>hist_grasscast_gp <span class="op">=</span> pd.read_csv(<span class="st">"../testing_data/aws/gp/hist_data_grasscast_gp.csv"</span>).clean_names()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Getting unique cell_ids as a Series</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>cell_ids_series <span class="op">=</span> pd.Series(hist_grasscast_gp[<span class="st">'gridid'</span>].unique(), name<span class="op">=</span><span class="st">'gridid'</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Join csv data to the shapefile by 'Id' and 'gridid' fields respectively</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>joined_data2 <span class="op">=</span> original_grid.merge(cell_ids_series.to_frame(), left_on<span class="op">=</span><span class="st">'Id'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>joined_data2.drop(<span class="st">'gridid'</span>, axis<span class="op">=</span><span class="dv">1</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>joined_data2 <span class="op">=</span> joined_data2.rename(columns<span class="op">=</span>{<span class="st">'Id'</span>: <span class="st">'gridid'</span>})</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>joined_data2 <span class="op">=</span> joined_data2.to_crs(epsg<span class="op">=</span><span class="dv">4326</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Below you can see the extracted grids that we will use for data representation.</p>
<div class="cell" data-execution_count="89">
<div class="cell-output cell-output-display">
<p><img src="foodsight_notebook_files/figure-html/cell-10-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="overlaping-cells" class="level6">
<h6 class="anchored" data-anchor-id="overlaping-cells">Overlaping cells</h6>
<p>When evaluating, we can see that there are some overlapping cells between both regions.</p>
<div class="cell" data-execution_count="93">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform an inner join on the 'gridid' column</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>shared_gridids_df <span class="op">=</span> pd.merge(gp_grid, sw_grid, on<span class="op">=</span><span class="st">'gridid'</span>, how<span class="op">=</span><span class="st">'inner'</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract unique 'gridid' values as a list</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>shared_gridids_list <span class="op">=</span> shared_gridids_df[<span class="st">'gridid'</span>].unique().tolist()</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Save cell ids to a JSON file</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>shared_gridids_df <span class="op">=</span> pd.DataFrame(shared_gridids_list, columns<span class="op">=</span>[<span class="st">'gridid'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These overlapping IDs will be stored for future use in preparing the datasets and for use in the Lambda functions that will periodically update the data.</p>
<div class="cell" data-execution_count="94">
<div class="cell-output cell-output-display">
<p><img src="foodsight_notebook_files/figure-html/cell-14-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>To prevent any issues when combining both areas, we will remove overlapping cells from the GP grid. Additionally, we will display the forecast calculated for the SW since, as we will see in the following section, it provides information for two different seasons and does not have as many information gaps as the GP.</p>
</section>
<section id="combining-both-regions" class="level6">
<h6 class="anchored" data-anchor-id="combining-both-regions">Combining both regions</h6>
<p>Now, we will combine both regions to create the final GeoJSON file that will be loaded into the app.</p>
<div class="cell" data-execution_count="95">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>gp_grid_exclusive <span class="op">=</span> gp_grid[<span class="op">~</span>gp_grid[<span class="st">'gridid'</span>].isin(shared_gridids_list)] <span class="co"># Exclude shared grid cells</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>combined_gdf <span class="op">=</span> gpd.GeoDataFrame(pd.concat([gp_grid_exclusive, sw_grid], ignore_index<span class="op">=</span><span class="va">True</span>)) <span class="co"># Combine the two GeoDataFrames</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="97">
<div class="cell-output cell-output-display">
<p><img src="foodsight_notebook_files/figure-html/cell-17-output-1.png" class="img-fluid"></p>
</div>
</div>
</section>
<section id="list-grid-cells-by-aoi" class="level6">
<h6 class="anchored" data-anchor-id="list-grid-cells-by-aoi">List grid cells by AOI</h6>
<p>Additionally, some of the backend code of the application will require knowing to which area (SW or GP) each cell is associated. Therefore, we will store a JSON file with the grid IDs grouped by the area of interest (AOI), whether it is SW or GP.</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>gp_grid <span class="op">=</span> gpd.read_file(<span class="st">"../testing_data/aws/spatial_data/gp_grid.geojson"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>sw_grid <span class="op">=</span> gpd.read_file(<span class="st">"../testing_data/aws/spatial_data/sw_grid.geojson"</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>shared_gridids_df <span class="op">=</span> pd.read_json(<span class="st">"../testing_data/aws/spatial_data/overlapping_gridids.json"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="63">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert gridid to the same type if necessary (if they are not already)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>gp_grid[<span class="st">'gridid'</span>] <span class="op">=</span> gp_grid[<span class="st">'gridid'</span>].astype(shared_gridids_df[<span class="st">'gridid'</span>].dtype)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove polygons from gp_grid where gridid matches those in shared_gridids_df</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>gp_grid_filtered <span class="op">=</span> gp_grid[<span class="op">~</span>gp_grid[<span class="st">'gridid'</span>].isin(shared_gridids_df[<span class="st">'gridid'</span>])]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract gridids from both gp_grid_filtered and sw_grid</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>gp_gridids <span class="op">=</span> gp_grid_filtered[<span class="st">'gridid'</span>].tolist()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>sw_gridids <span class="op">=</span> sw_grid[<span class="st">'gridid'</span>].tolist()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dictionary for JSON structure</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>json_data <span class="op">=</span> [</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"aoi"</span>: <span class="st">"gp"</span>, <span class="st">"gridid"</span>: gp_gridids},</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    {<span class="st">"aoi"</span>: <span class="st">"sw"</span>, <span class="st">"gridid"</span>: sw_gridids}</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert dictionary to JSON</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>json_output <span class="op">=</span> json.dumps(json_data, indent<span class="op">=</span><span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="counties" class="level5">
<h5 class="anchored" data-anchor-id="counties">Counties</h5>
<p>Here we will extract all the counties polygons that contain any GrassCast grid cell. The resulting geojson will be loaded into the app to help performing calculations based on county areas.</p>
<div class="cell" data-execution_count="99">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># read geojosn file</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>us_counties <span class="op">=</span> gpd.read_file(<span class="st">"../testing_data/aws/spatial_data/us_counties.geojson"</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>grasscast_grid <span class="op">=</span> gpd.read_file(<span class="st">"../testing_data/aws/spatial_data/grasscast_aoi_grid.geojson"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="101">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform a spatial join to find counties that intersect with grasscast_grid polygons</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>selected_counties <span class="op">=</span> gpd.sjoin(us_counties, grasscast_grid, how<span class="op">=</span><span class="st">'inner'</span>, predicate<span class="op">=</span><span class="st">'contains'</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop duplicates if necessary (to get unique list of counties)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>selected_counties <span class="op">=</span> selected_counties.drop_duplicates(subset<span class="op">=</span><span class="st">'COUNTYNS'</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the CSV file with state and state USPS mappings</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>state_usps_df <span class="op">=</span> pd.read_csv(<span class="st">"../testing_data/aws/spatial_data/us_states_abbreviations.csv"</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge the selected_counties with the state_usps_df</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>selected_counties_merged <span class="op">=</span> selected_counties.merge(state_usps_df, left_on<span class="op">=</span><span class="st">'STATENAME'</span>, right_on<span class="op">=</span><span class="st">'state'</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a column that indicates the AOI</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>selected_counties_merged[<span class="st">'aoi'</span>] <span class="op">=</span> selected_counties_merged[<span class="st">'state_usps'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">'sw'</span> <span class="cf">if</span> x <span class="kw">in</span> [<span class="st">'AZ'</span>, <span class="st">'NM'</span>] <span class="cf">else</span> <span class="st">'gp'</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Select variables of interest</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>selected_counties_short <span class="op">=</span> selected_counties_merged[[<span class="st">"NAME"</span>,<span class="st">"state"</span>, <span class="st">"state_usps"</span>, <span class="st">"aoi"</span>, <span class="st">"geometry"</span>]].clean_names()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="102">
<div class="cell-output cell-output-display">
<p><img src="foodsight_notebook_files/figure-html/cell-24-output-1.png" class="img-fluid"></p>
</div>
</div>
<div class="cell" data-execution_count="159">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>selected_counties_short.to_file(<span class="st">"../testing_data/aws/spatial_data/grasscast_counties.geojson"</span>, driver<span class="op">=</span><span class="st">'GeoJSON'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="grasscast-data" class="level4">
<h4 class="anchored" data-anchor-id="grasscast-data">Grasscast Data</h4>
<p>Grasscast forecast outputs can be accessed from the <a href="https://grasscast.unl.edu/">https://grasscast.unl.edu/</a> website in CSV format. In the “Maps Archive” section, you can query based on date. To simplify the precess and access all available forecast data for the first time, we can automate the download with the following function.</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> download_csv_as_dataframes(start_year<span class="op">=</span><span class="dv">2020</span>, end_year<span class="op">=</span>date.today().year, region_code<span class="op">=</span><span class="st">'gp'</span>):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    base_url <span class="op">=</span> <span class="st">"https://grasscast.unl.edu/data/csv/</span><span class="sc">{year}</span><span class="st">/ANPP_forecast_summary_</span><span class="sc">{region_code}</span><span class="st">_</span><span class="sc">{year}</span><span class="st">_</span><span class="sc">{month}</span><span class="st">_</span><span class="sc">{day}</span><span class="st">.csv"</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    dataframes <span class="op">=</span> {}</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    month_names <span class="op">=</span> {<span class="dv">4</span>: <span class="st">"April"</span>, <span class="dv">5</span>: <span class="st">"May"</span>, <span class="dv">6</span>: <span class="st">"June"</span>, <span class="dv">7</span>: <span class="st">"July"</span>, <span class="dv">8</span>: <span class="st">"August"</span>, <span class="dv">9</span>: <span class="st">"September"</span>}</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> year <span class="kw">in</span> <span class="bu">range</span>(start_year, end_year <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> month <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>, <span class="dv">10</span>):  <span class="co"># From April to September</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Setting the end day of the month</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> month <span class="kw">in</span> [<span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">9</span>]:  <span class="co"># April, June, September have 30 days</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                end_day <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                end_day <span class="op">=</span> <span class="dv">31</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> day <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, end_day <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Constructing the URL for each specific date</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                url <span class="op">=</span> base_url.<span class="bu">format</span>(year<span class="op">=</span>year, region_code<span class="op">=</span>region_code, month<span class="op">=</span>month_names[month], day<span class="op">=</span>day)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(url)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                    response <span class="op">=</span> requests.get(url)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> response.status_code <span class="op">==</span> <span class="dv">200</span>:</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Reading the CSV into a Pandas dataframe</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>                        dataframe <span class="op">=</span> pd.read_csv(url)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Storing the dataframe with a key indicating the date</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                        df_key <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>day<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>                        dataframes[df_key] <span class="op">=</span> dataframe</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">print</span>(<span class="ss">f"Data found and downloaded for date: </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>day<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">print</span>(<span class="ss">f"No data available for date: </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>day<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Error downloading file for date: </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>day<span class="sc">}</span><span class="ss">, Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataframes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Forecast for the Soith West has the forecast divided into two seasons, spring and summer, while the predictions for the Great Plains are summarized into a single season. Therefore, we will access and treat the data separatelly.</p>
<section id="forecast-data" class="level5">
<h5 class="anchored" data-anchor-id="forecast-data">Forecast Data</h5>
<section id="great-plains" class="level6">
<h6 class="anchored" data-anchor-id="great-plains">Great Plains</h6>
<section id="forecast-data-access-and-wrangling" class="level7">
<p class="heading">Forecast Data access and wrangling</p>
<p>By applying the previous function, we will obtain a dictionary of dataframes, which will require further processing.</p>
<div class="cell" data-execution_count="113">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Downloading the available data using the function defined above</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>dataframes <span class="op">=</span> download_csv_as_dataframes(region_code<span class="op">=</span><span class="st">'gp'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>From year to year, the variables have been stored with different names. Let’s identify which columns are affected and rename them accordingly.</p>
<div class="cell" data-execution_count="114">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> check_column_consistency(dataframes):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    shared_columns <span class="op">=</span> <span class="bu">set</span>(dataframes[<span class="bu">next</span>(<span class="bu">iter</span>(dataframes))].columns)  <span class="co"># Initialize with columns of the first dataframe</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    unique_columns <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> df_key, df <span class="kw">in</span> dataframes.items():</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        current_columns <span class="op">=</span> <span class="bu">set</span>(df.columns)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        shared_columns <span class="op">=</span> shared_columns.intersection(current_columns)  <span class="co"># Keep only columns that are shared</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        unique_columns <span class="op">=</span> unique_columns.union(current_columns.difference(shared_columns))  <span class="co"># Collect unique columns</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(shared_columns), <span class="bu">list</span>(unique_columns)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>shared_cols, unique_cols <span class="op">=</span> check_column_consistency(dataframes)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shared columns:"</span>, shared_cols)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique columns:"</span>, unique_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With the column names identified, let’s rename them so that we can later merge the dataframes by column.</p>
<div class="cell" data-execution_count="116">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rename_dataframe_columns(dataframes_dict):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    rename_dict <span class="op">=</span> {</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2020_below'</span>: <span class="st">'NDVI_predict_below'</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2020_below'</span>: <span class="st">'NPP_predict_below'</span>,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2020_avg'</span>: <span class="st">'NDVI_predict_avg'</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2020_avg'</span>: <span class="st">'NPP_predict_avg'</span>,</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2020_above'</span>: <span class="st">'NDVI_predict_above'</span>,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2020_above'</span>: <span class="st">'NPP_predict_above'</span>,</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2021_below'</span>: <span class="st">'NDVI_predict_below'</span>,</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2021_below'</span>: <span class="st">'NPP_predict_below'</span>,</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2021_avg'</span>: <span class="st">'NDVI_predict_avg'</span>,</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2021_avg'</span>: <span class="st">'NPP_predict_avg'</span>,</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2021_above'</span>: <span class="st">'NDVI_predict_above'</span>,</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2021_above'</span>: <span class="st">'NPP_predict_above'</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, df <span class="kw">in</span> dataframes_dict.items():</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Renaming the columns as per the rename_dict</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Using inplace=True to modify the dataframe in place</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        df.rename(columns<span class="op">=</span>{col: rename_dict[col] <span class="cf">for</span> col <span class="kw">in</span> df.columns <span class="cf">if</span> col <span class="kw">in</span> rename_dict}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataframes_dict</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>renamed_dataframes <span class="op">=</span> rename_dataframe_columns(dataframes)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>shared_cols, unique_cols <span class="op">=</span> check_column_consistency(renamed_dataframes)</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shared columns:"</span>, shared_cols)</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique columns:"</span>, unique_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we apply this, we can observe that there are still some unique columns not shared by all dataframes. Let’s explore the dates associated with the remaining unique columns.</p>
<div class="cell" data-execution_count="119">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_dataframes_with_columns(dataframes_dict, unique_columns):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    found_columns_in_dfs <span class="op">=</span> {}</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, df <span class="kw">in</span> dataframes_dict.items():</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if any of the unique columns are in the dataframe's columns</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        found_columns <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> unique_columns <span class="cf">if</span> col <span class="kw">in</span> df.columns]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> found_columns:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>            found_columns_in_dfs[key] <span class="op">=</span> found_columns</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> found_columns_in_dfs</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the unique columns</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>unique_columns <span class="op">=</span> [<span class="st">'PPTgs_avg'</span>, <span class="st">'pptGSremainder_above'</span>, <span class="st">'pptGSremainder_below'</span>, </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'pptAvgWatYrReceived'</span>, <span class="st">'pptGSremainder_avg'</span>, <span class="st">'PPTgs_below'</span>, </span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'pptWatYrReceived'</span>, <span class="st">'PPTgs_above'</span>]</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>dataframes_with_unique_columns <span class="op">=</span> find_dataframes_with_columns(renamed_dataframes, unique_columns)</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, cols <span class="kw">in</span> dataframes_with_unique_columns.items():</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"DataFrame Key: </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>DataFrame Key: 2022_4_5
DataFrame Key: 2022_4_19
DataFrame Key: 2022_5_3
DataFrame Key: 2022_5_17
DataFrame Key: 2022_5_31
DataFrame Key: 2022_6_14
DataFrame Key: 2022_6_28
DataFrame Key: 2022_7_12
DataFrame Key: 2022_7_26
DataFrame Key: 2022_8_9
DataFrame Key: 2022_8_23
DataFrame Key: 2022_9_1
DataFrame Key: 2023_4_4
DataFrame Key: 2023_4_18
DataFrame Key: 2023_5_2
DataFrame Key: 2023_5_16
DataFrame Key: 2023_5_31
DataFrame Key: 2023_6_13
DataFrame Key: 2023_6_27
DataFrame Key: 2023_7_11
DataFrame Key: 2023_7_25
DataFrame Key: 2023_8_22
DataFrame Key: 2023_9_6</code></pre>
</div>
</div>
<p>As we can see, these columns are not shared by all of the forecast data for different years. Since our only interest is in the ANPP, we will proceed to remove these columns.</p>
<div class="cell" data-execution_count="120">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> discard_columns_from_dataframes(dataframes_dict, columns_to_discard):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, df <span class="kw">in</span> dataframes_dict.items():</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Dropping the specified columns if they exist in the dataframe</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> columns_to_discard <span class="cf">if</span> col <span class="kw">in</span> df.columns], inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataframes_dict</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the columns to discard</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>unique_columns <span class="op">=</span> [<span class="st">'PPTgs_avg'</span>, <span class="st">'pptGSremainder_above'</span>, <span class="st">'pptGSremainder_below'</span>, </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'pptAvgWatYrReceived'</span>, <span class="st">'pptGSremainder_avg'</span>, <span class="st">'PPTgs_below'</span>, </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                  <span class="st">'pptWatYrReceived'</span>, <span class="st">'PPTgs_above'</span>]</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage </span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>cleaned_dataframes_dict <span class="op">=</span> discard_columns_from_dataframes(renamed_dataframes, unique_columns)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>shared_cols, unique_cols <span class="op">=</span> check_column_consistency(cleaned_dataframes_dict)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shared columns:"</span>, shared_cols)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique columns:"</span>, unique_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now that we have the datasets with the variables of interest, before combining all dataframes into a single one, let’s add a variable ‘report_date’ containing the date of the CSV report.</p>
<div class="cell" data-execution_count="122">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_report_date_to_dataframes(dataframes_dict):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, df <span class="kw">in</span> dataframes_dict.items():</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Parsing the key to construct the date in 'yyyy-mm-dd' format</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        year, month, day <span class="op">=</span> key.split(<span class="st">'_'</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        report_date <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>month<span class="sc">.</span>zfill(<span class="dv">2</span>)<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>day<span class="sc">.</span>zfill(<span class="dv">2</span>)<span class="sc">}</span><span class="ss">"</span>  <span class="co"># ensuring month and day are two digits</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Adding the new column 'report_date' to the dataframe</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'report_date'</span>] <span class="op">=</span> report_date</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataframes_dict</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>cleaned_dataframes_dict_with_dates <span class="op">=</span>add_report_date_to_dataframes(cleaned_dataframes_dict)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, with the dataframes cleaned, let’s join them into a single dataframe and save it as a CSV.</p>
<div class="cell" data-execution_count="124">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> combine_dataframes(dataframes_dict):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract all dataframes into a list</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    dfs <span class="op">=</span> <span class="bu">list</span>(dataframes_dict.values())</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine dataframes, keeping only common columns</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    combined_df <span class="op">=</span> pd.concat(dfs, join<span class="op">=</span><span class="st">'inner'</span>, ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> combined_df</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>combined_dataframe <span class="op">=</span> combine_dataframes(cleaned_dataframes_dict_with_dates)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once we are done, we can save it, but before, we should standardize the column names.</p>
<div class="cell" data-execution_count="125">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>combined_dataframe <span class="op">=</span> combined_dataframe.clean_names()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="southwest" class="level6">
<h6 class="anchored" data-anchor-id="southwest">Southwest</h6>
<p>The same procedure will apply to the SW data with slight differences due to different variable names.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Downloading the available data using the function defined above</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>dataframes <span class="op">=</span> download_csv_as_dataframes(region_code<span class="op">=</span><span class="st">'sw'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can use the previously defined function to identify variables that have been stored with distinct names.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>shared_cols, unique_cols <span class="op">=</span> check_column_consistency(dataframes)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shared columns:"</span>, shared_cols)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique columns:"</span>, unique_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Shared columns: ['meanANPPgrid', 'pct_diffNPP_avg', 'deltaNPP_below', 'Indx', 'NPP_stdev_below', 'deltaNPP_avg', 'meanNDVIgrid', 'Fips', 'NPP_stdev_avg', 'pct_diffNPP_below', 'CountyState', 'pct_diffNPP_above', 'deltaNPP_above', 'gridID', 'Year', 'NPP_stdev_above']
Unique columns: ['NDVI_predict_2021_above', 'NPP_predict_2021_above', 'pptAvgJunReceived', 'NPP_predict_avg', 'NPP_predict_2021_avg', 'pptGSremainder_below', 'NDVI_predict_2021_below', 'pptWatYrReceived', 'pptAvgWatYrReceived', 'PPTgs_below', 'pptGSremainder_above', 'NPP_predict_above', 'NDVI_predict_avg', 'NDVI_predict_above', 'NPP_predict_2021_below', 'PPTgs_avg', 'NDVI_predict_2021_avg', 'pptGSremainder_avg', 'pptJunReceived', 'NDVI_predict_below', 'NPP_predict_below', 'PPTgs_above']</code></pre>
</div>
</div>
<p>With the column names identified, we will see that they differ from the previous ones. With this information, let’s proceed to rename them, making it easier for us to merge the dataframes by column later on.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rename_dataframe_columns(dataframes_dict):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    rename_dict <span class="op">=</span> {</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2019_below'</span>: <span class="st">'NDVI_predict_below'</span>,</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2019_below'</span>: <span class="st">'NPP_predict_below'</span>,</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2019_avg'</span>: <span class="st">'NDVI_predict_avg'</span>,</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2019_avg'</span>: <span class="st">'NPP_predict_avg'</span>,</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2019_above'</span>: <span class="st">'NDVI_predict_above'</span>,</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2019_above'</span>: <span class="st">'NPP_predict_above'</span>,</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2020_below'</span>: <span class="st">'NDVI_predict_below'</span>,</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2020_below'</span>: <span class="st">'NPP_predict_below'</span>,</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2020_avg'</span>: <span class="st">'NDVI_predict_avg'</span>,</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2020_avg'</span>: <span class="st">'NPP_predict_avg'</span>,</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2020_above'</span>: <span class="st">'NDVI_predict_above'</span>,</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2020_above'</span>: <span class="st">'NPP_predict_above'</span>,</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2021_below'</span>: <span class="st">'NDVI_predict_below'</span>,</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2021_below'</span>: <span class="st">'NPP_predict_below'</span>,</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2021_avg'</span>: <span class="st">'NDVI_predict_avg'</span>,</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2021_avg'</span>: <span class="st">'NPP_predict_avg'</span>,</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NDVI_predict_2021_above'</span>: <span class="st">'NDVI_predict_above'</span>,</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="st">'NPP_predict_2021_above'</span>: <span class="st">'NPP_predict_above'</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, df <span class="kw">in</span> dataframes_dict.items():</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Renaming the columns as per the rename_dict</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Using inplace=True to modify the dataframe in place</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        df.rename(columns<span class="op">=</span>{col: rename_dict[col] <span class="cf">for</span> col <span class="kw">in</span> df.columns <span class="cf">if</span> col <span class="kw">in</span> rename_dict}, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataframes_dict</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>renamed_dataframes <span class="op">=</span> rename_dataframe_columns(dataframes)</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>shared_cols, unique_cols <span class="op">=</span> check_column_consistency(renamed_dataframes)</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shared columns:"</span>, shared_cols)</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique columns:"</span>, unique_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are still some distict columns not shared by all dataframes. Let’s check the dates associated with these.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_dataframes_with_columns(dataframes_dict, unique_columns):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    found_columns_in_dfs <span class="op">=</span> {}</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, df <span class="kw">in</span> dataframes_dict.items():</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if any of the unique columns are in the dataframe's columns</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        found_columns <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> unique_columns <span class="cf">if</span> col <span class="kw">in</span> df.columns]</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> found_columns:</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>            found_columns_in_dfs[key] <span class="op">=</span> found_columns</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> found_columns_in_dfs</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the unique columns</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>unique_columns <span class="op">=</span> [<span class="st">'PPTgs_avg'</span>, <span class="st">'pptAvgJunReceived'</span>, <span class="st">'pptGSremainder_below'</span>, <span class="st">'pptGSremainder_avg'</span>,</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'pptWatYrReceived'</span>, <span class="st">'pptAvgWatYrReceived'</span>, <span class="st">'PPTgs_below'</span>, <span class="st">'pptGSremainder_above'</span>,</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'pptJunReceived'</span>, <span class="st">'PPTgs_above'</span>]</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>dataframes_with_unique_columns <span class="op">=</span> find_dataframes_with_columns(renamed_dataframes, unique_columns)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, cols <span class="kw">in</span> dataframes_with_unique_columns.items():</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"DataFrame Key: </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>DataFrame Key: 2022_4_5
DataFrame Key: 2022_4_19
DataFrame Key: 2022_5_3
DataFrame Key: 2022_5_17
DataFrame Key: 2022_5_31
DataFrame Key: 2022_6_14
DataFrame Key: 2022_6_28
DataFrame Key: 2022_7_12
DataFrame Key: 2022_7_26
DataFrame Key: 2022_8_9
DataFrame Key: 2022_8_23
DataFrame Key: 2022_9_1
DataFrame Key: 2023_4_4
DataFrame Key: 2023_4_18
DataFrame Key: 2023_5_2
DataFrame Key: 2023_5_16
DataFrame Key: 2023_5_31
DataFrame Key: 2023_6_13
DataFrame Key: 2023_6_27
DataFrame Key: 2023_7_11
DataFrame Key: 2023_7_25
DataFrame Key: 2023_8_22
DataFrame Key: 2023_9_6</code></pre>
</div>
</div>
<p>Running the previous function, we can observe that these columns are not shared among all the forecast data for different years. Since our only interest is in the ANPP, we will proceed to remove these columns.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> discard_columns_from_dataframes(dataframes_dict, columns_to_discard):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> key, df <span class="kw">in</span> dataframes_dict.items():</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Dropping the specified columns if they exist in the dataframe</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        df.drop(columns<span class="op">=</span>[col <span class="cf">for</span> col <span class="kw">in</span> columns_to_discard <span class="cf">if</span> col <span class="kw">in</span> df.columns], inplace<span class="op">=</span><span class="va">True</span>, errors<span class="op">=</span><span class="st">'ignore'</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataframes_dict</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the columns to discard</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>unique_columns <span class="op">=</span> [<span class="st">'PPTgs_avg'</span>, <span class="st">'pptAvgJunReceived'</span>, <span class="st">'pptGSremainder_below'</span>, <span class="st">'pptGSremainder_avg'</span>,</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>                   <span class="st">'pptWatYrReceived'</span>, <span class="st">'pptAvgWatYrReceived'</span>, <span class="st">'PPTgs_below'</span>, <span class="st">'pptGSremainder_above'</span>,</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>                    <span class="st">'pptJunReceived'</span>, <span class="st">'PPTgs_above'</span>]</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage </span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>cleaned_dataframes_dict <span class="op">=</span> discard_columns_from_dataframes(renamed_dataframes, unique_columns)</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>shared_cols, unique_cols <span class="op">=</span> check_column_consistency(cleaned_dataframes_dict)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shared columns:"</span>, shared_cols)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Unique columns:"</span>, unique_cols)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, let’s proceed with the remaining processing steps, which involve adding the report date, combining the data, and standardizing the dataset.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>cleaned_dataframes_dict_with_dates <span class="op">=</span>add_report_date_to_dataframes(cleaned_dataframes_dict)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>combined_dataframe <span class="op">=</span> combine_dataframes(cleaned_dataframes_dict_with_dates)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>combined_dataframe <span class="op">=</span> combined_dataframe.clean_names()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="historic-data" class="level5">
<h5 class="anchored" data-anchor-id="historic-data">Historic Data</h5>
<p>The complete historic series is not available on the Grasscast website. These were obtained upon request from the Grasscast team. This section explores the data and processes it so that it can be used in the application.</p>
<section id="great-plains-1" class="level6">
<h6 class="anchored" data-anchor-id="great-plains-1">Great Plains</h6>
<p>Working with the GP dataset, let’s first standardize the column names before proceeding further.</p>
<div class="cell" data-execution_count="111">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>hist_grasscast_gp <span class="op">=</span> hist_grasscast_gp.clean_names()</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove_trailing_underscores(name):</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> name.rstrip(<span class="st">'_'</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>hist_grasscast_gp.columns <span class="op">=</span> [remove_trailing_underscores(col) <span class="cf">for</span> col <span class="kw">in</span> hist_grasscast_gp.columns]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>hist_grasscast_gp.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="111">
<pre><code>Index(['fips', 'gridid', 'countyst', 'latitude', 'longitude', 'year',
       'pptamjj_cm', 'pptamjja_cm', 'aetamjj_cm', 'aetamjja_cm', 'anpp_lbs_ac',
       'pptamjj_mean_cm', 'pptamjja_mean_cm', 'aetamjj_mean_cm',
       'aetamjja_mean_cm', 'anpp_mean_lbs_ac', 'anpp_percent_diff_%'],
      dtype='object')</code></pre>
</div>
</div>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>hist_grasscast_gp[<span class="st">'year'</span>].unique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>array([1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992,
       1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
       2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014,
       2015, 2016, 2017, 2018, 2019])</code></pre>
</div>
</div>
<p>While exploring the years, we can observe that there is data available up to 2019. Therefore, we will have to add the last recorded values for each remaining year from the forecast dataframe created earlier. We will follow this approach for all years except for the last available year. For the last available year, its values will need to be correlated against the expected climate for the season.</p>
<div class="cell" data-execution_count="105">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert 'report_date' to datetime</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>forecast_grasscast_gp[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(forecast_grasscast_gp[<span class="st">'report_date'</span>])</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Group by 'Year' and get the last 'report_date'</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>max_dates_per_year <span class="op">=</span> forecast_grasscast_gp.groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_dates_per_year)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>year
2020   2020-09-01
2021   2021-08-24
2022   2022-09-01
2023   2023-09-06
Name: report_date, dtype: datetime64[ns]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="108">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge to get only the observations on the last report date of each year</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> pd.merge(forecast_grasscast_gp, max_dates_per_year, on<span class="op">=</span>[<span class="st">'year'</span>, <span class="st">'report_date'</span>])</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Selecting only the specified columns</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>result[<span class="st">"anpp_lbs_ac"</span>] <span class="op">=</span> result[[<span class="st">"npp_predict_below"</span>, <span class="st">"npp_predict_avg"</span>, <span class="st">"npp_predict_above"</span>]].mean(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the selected columns</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>result[[<span class="st">"gridid"</span>,<span class="st">"year"</span>,<span class="st">"anpp_lbs_ac"</span>,<span class="st">"npp_predict_below"</span>, <span class="st">"npp_predict_avg"</span>, <span class="st">"npp_predict_above"</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="108">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">gridid</th>
<th data-quarto-table-cell-role="th">year</th>
<th data-quarto-table-cell-role="th">anpp_lbs_ac</th>
<th data-quarto-table-cell-role="th">npp_predict_below</th>
<th data-quarto-table-cell-role="th">npp_predict_avg</th>
<th data-quarto-table-cell-role="th">npp_predict_above</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>74844</td>
<td>2020</td>
<td>631.1814</td>
<td>631.1814</td>
<td>631.1814</td>
<td>631.1814</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>74845</td>
<td>2020</td>
<td>626.9868</td>
<td>626.9868</td>
<td>626.9868</td>
<td>626.9868</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>74846</td>
<td>2020</td>
<td>635.6654</td>
<td>635.6654</td>
<td>635.6654</td>
<td>635.6654</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>74847</td>
<td>2020</td>
<td>638.6883</td>
<td>638.6883</td>
<td>638.6883</td>
<td>638.6883</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>74848</td>
<td>2020</td>
<td>644.6118</td>
<td>644.6118</td>
<td>644.6118</td>
<td>644.6118</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Combine the variables of interest into a single dataframe to be read in the app.</p>
<div class="cell" data-execution_count="112">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select the specified columns from hist_grasscast_gp</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>selected_columns_hist <span class="op">=</span> hist_grasscast_gp[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"anpp_lbs_ac"</span>]]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>selected_columns_forecast <span class="op">=</span> result[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"anpp_lbs_ac"</span>]]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>combined_df <span class="op">=</span> pd.concat([selected_columns_hist, selected_columns_forecast], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>combined_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="112">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">gridid</th>
<th data-quarto-table-cell-role="th">year</th>
<th data-quarto-table-cell-role="th">anpp_lbs_ac</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>74844</td>
<td>1982</td>
<td>843.26</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>74844</td>
<td>1983</td>
<td>1066.65</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>74844</td>
<td>1984</td>
<td>775.78</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>74844</td>
<td>1985</td>
<td>870.02</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>74844</td>
<td>1986</td>
<td>748.74</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Before saving it, we will exclude the overlapping cells with the SW area and remove the observations for the last available year, which will be updated later.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the 'gridid' in overlapping_ids to a set for faster lookup</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>overlapping_ids_set <span class="op">=</span> <span class="bu">set</span>(overlapping_ids[<span class="st">'gridid'</span>])</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a boolean index for rows in combined_df where 'gridid' is not in overlapping_ids_set</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>non_overlapping_index <span class="op">=</span> <span class="op">~</span>combined_df[<span class="st">'gridid'</span>].isin(overlapping_ids_set)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter the combined_df using this index</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>filtered_combined_df <span class="op">=</span> combined_df[non_overlapping_index]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove rows where 'year' is 2023</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>filtered_combined_df <span class="op">=</span> filtered_combined_df[filtered_combined_df[<span class="st">'year'</span>] <span class="op">!=</span> <span class="dv">2023</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="southwest-1" class="level6">
<h6 class="anchored" data-anchor-id="southwest-1">Southwest</h6>
<p>We will apply the same procedure to the SW data.</p>
<div class="cell" data-execution_count="118">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>hist_grasscast_sw <span class="op">=</span> hist_grasscast_sw.clean_names()</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>hist_grasscast_sw.columns <span class="op">=</span> [remove_trailing_underscores(col) <span class="cf">for</span> col <span class="kw">in</span> hist_grasscast_sw.columns]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The historical forecast data for SW has the predictions divided into two seasons: spring and summer. Therefore, here we will treat the values from April to June differently from those for the following months.</p>
<div class="cell" data-execution_count="119">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the 'Date' column to datetime if it's not</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>forecast_grasscast_sw[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(forecast_grasscast_sw[<span class="st">'report_date'</span>])</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter the dataframe for the last day of May and the last day of the year</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>last_day_may <span class="op">=</span> forecast_grasscast_sw[forecast_grasscast_sw[<span class="st">'report_date'</span>].dt.month <span class="op">==</span> <span class="dv">5</span>].groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>last_day_year <span class="op">=</span> forecast_grasscast_sw.groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Group by 'Year' and get the last 'report_date'</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>max_dates_per_year <span class="op">=</span> pd.concat([last_day_may, last_day_year])</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_dates_per_year)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>year
2020   2020-05-15
2021   2021-05-18
2022   2022-05-31
2023   2023-05-31
2020   2020-09-01
2021   2021-08-24
2022   2022-09-01
2023   2023-09-06
Name: report_date, dtype: datetime64[ns]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="123">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> pd.merge(forecast_grasscast_sw, max_dates_per_year, on<span class="op">=</span>[<span class="st">'year'</span>, <span class="st">'report_date'</span>])</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Add a new column to classify the report_date into 'spring' or 'summer'</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the month from report_date</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'month'</span>] <span class="op">=</span> pd.to_datetime(result[<span class="st">'report_date'</span>]).dt.month</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign 'spring' or 'summer' based on the month</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'season'</span>] <span class="op">=</span> result[<span class="st">'month'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">'spring'</span> <span class="cf">if</span> <span class="dv">4</span> <span class="op">&lt;=</span> x <span class="op">&lt;</span> <span class="dv">6</span> <span class="cf">else</span> <span class="st">'summer'</span>)</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate mean values for spring and summer separately</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'predicted_spring_anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[[<span class="st">"npp_predict_below"</span>, <span class="st">"npp_predict_avg"</span>, <span class="st">"npp_predict_above"</span>]].mean() <span class="cf">if</span> row[<span class="st">'season'</span>] <span class="op">==</span> <span class="st">'spring'</span> <span class="cf">else</span> <span class="va">None</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'predicted_summer_anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[[<span class="st">"npp_predict_below"</span>, <span class="st">"npp_predict_avg"</span>, <span class="st">"npp_predict_above"</span>]].mean() <span class="cf">if</span> row[<span class="st">'season'</span>] <span class="op">==</span> <span class="st">'summer'</span> <span class="cf">else</span> <span class="va">None</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop the temporary columns if not needed</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> result.drop([<span class="st">'month'</span>, <span class="st">'season'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Select the specified columns from hist_grasscast_gp</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>selected_columns_hist <span class="op">=</span> hist_grasscast_sw[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"predicted_spring_anpp_lbs_ac"</span>, <span class="st">"predicted_summer_anpp_lbs_ac"</span>]]</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>selected_columns_forecast <span class="op">=</span> result[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"predicted_spring_anpp_lbs_ac"</span>, <span class="st">"predicted_summer_anpp_lbs_ac"</span>]]</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a final dataframe with the historical dataframe structure</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>merged_selected_columns_forecast <span class="op">=</span> selected_columns_forecast.groupby([<span class="st">'gridid'</span>, <span class="st">'year'</span>], as_index<span class="op">=</span><span class="va">False</span>).first()</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine the formated forecast dataframe with the historical dataframe</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>combined_df <span class="op">=</span> pd.concat([selected_columns_hist, merged_selected_columns_forecast], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Exclude last year observations</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>combined_df <span class="op">=</span> combined_df[combined_df[<span class="st">'year'</span>] <span class="op">!=</span> <span class="dv">2023</span>]</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>combined_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="123">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">gridid</th>
<th data-quarto-table-cell-role="th">year</th>
<th data-quarto-table-cell-role="th">predicted_spring_anpp_lbs_ac</th>
<th data-quarto-table-cell-role="th">predicted_summer_anpp_lbs_ac</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>45748</td>
<td>1982</td>
<td>336.29</td>
<td>489.48</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>45748</td>
<td>1983</td>
<td>332.46</td>
<td>601.13</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>45748</td>
<td>1984</td>
<td>331.40</td>
<td>569.19</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>45748</td>
<td>1985</td>
<td>343.90</td>
<td>512.03</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>45748</td>
<td>1986</td>
<td>329.19</td>
<td>544.87</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</section>
</section>
</section>
<section id="climate-data-forecast-corrections" class="level4">
<h4 class="anchored" data-anchor-id="climate-data-forecast-corrections">Climate data &amp; forecast corrections</h4>
<p>To determine which of the ANPP projections is more likely to occur, GrassCast redirects us to the NOAA Climate Prediction Center (<a href="https://www.cpc.ncep.noaa.gov/products/predictions/long_range/interactive/index.php">https://www.cpc.ncep.noaa.gov/products/predictions/long_range/interactive/index.php</a> ). There, we can check the monthly and seasonal precipitation outlooks. The function below is used to streamline the data access and download the shapefile containing the precipitation outlooks.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clear_directory(path):</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> os.listdir(path):</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        file_path <span class="op">=</span> os.path.join(path, <span class="bu">file</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> os.path.isfile(file_path):</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>            os.unlink(file_path)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> os.path.isdir(file_path):</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Recursively clear and delete the subdirectory</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            clear_directory(file_path)</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>            os.rmdir(file_path)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> download_and_extract_seasprcp_files(year, month, save_path):</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if the month is between April and July</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> month <span class="op">&lt;</span> <span class="dv">4</span> <span class="kw">or</span> month <span class="op">&gt;</span> <span class="dv">7</span>:</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"No download required. Month is not between April and July."</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    base_url <span class="op">=</span> <span class="st">'https://ftp.cpc.ncep.noaa.gov/GIS/us_tempprcpfcst/'</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    filename <span class="op">=</span> <span class="st">'seasprcp_</span><span class="sc">{0:04d}{1:02d}</span><span class="st">.zip'</span>.<span class="bu">format</span>(year, month)</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    url <span class="op">=</span> base_url <span class="op">+</span> filename</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ensure the save_path directory exists and is empty</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> os.path.exists(save_path):</span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>            os.makedirs(save_path)</span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>            clear_directory(save_path)</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Download the ZIP file</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>        response <span class="op">=</span> requests.get(url)</span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>        response.raise_for_status()</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Save the ZIP file temporarily</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>        temp_zip_path <span class="op">=</span> os.path.join(save_path, filename)</span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="bu">open</span>(temp_zip_path, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a>            f.write(response.content)</span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract only files starting with 'lead1'</span></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> zipfile.ZipFile(temp_zip_path, <span class="st">'r'</span>) <span class="im">as</span> zip_ref:</span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> zip_ref.namelist():</span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">file</span>.startswith(<span class="st">'lead1_'</span>):</span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>                    zip_ref.extract(<span class="bu">file</span>, save_path)</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Optionally, remove the ZIP file after extraction</span></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>        os.remove(temp_zip_path)</span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"Files starting with 'lead1' extracted successfully."</span></span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> requests.exceptions.HTTPError <span class="im">as</span> err:</span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"HTTP Error: "</span> <span class="op">+</span> <span class="bu">str</span>(err)</span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> zipfile.BadZipFile:</span>
<span id="cb43-50"><a href="#cb43-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"Error: The downloaded file is not a zip file."</span></span>
<span id="cb43-51"><a href="#cb43-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb43-52"><a href="#cb43-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"Error: "</span> <span class="op">+</span> <span class="bu">str</span>(e)</span>
<span id="cb43-53"><a href="#cb43-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-54"><a href="#cb43-54" aria-hidden="true" tabindex="-1"></a>seasprcp_shp_path <span class="op">=</span> <span class="st">'../testing_data/aws/climate_data/seasprcp/'</span></span>
<span id="cb43-55"><a href="#cb43-55" aria-hidden="true" tabindex="-1"></a>download_and_extract_seasprcp_files(<span class="dv">2023</span>, <span class="dv">6</span>, seasprcp_shp_path)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Upon examining the data, you will notice that different areas have different classifications for below-average and above-normal precipitation conditions. These classifications are accompanied by associated probabilities of occurrence.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Read downloaded shapefile</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>seasprcp_202306_shp_path <span class="op">=</span> <span class="st">'../testing_data/aws/climate_data/seasprcp/lead1_JAS_prcp.shp'</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>seasprcp_202306_raw <span class="op">=</span> gpd.read_file(seasprcp_202306_shp_path).to_crs(epsg<span class="op">=</span><span class="dv">4326</span>)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Transforming probabikity variable to account for all decimals</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>seasprcp_202306_raw[<span class="st">'Prob'</span>] <span class="op">=</span> seasprcp_202306_raw[<span class="st">'Prob'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)<span class="op">*</span><span class="dv">100</span> <span class="cf">if</span> x <span class="op">==</span> <span class="fl">33.0</span> <span class="cf">else</span> x)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>seasprcp_202306_raw.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Fcst_Date</th>
<th data-quarto-table-cell-role="th">Valid_Seas</th>
<th data-quarto-table-cell-role="th">Prob</th>
<th data-quarto-table-cell-role="th">Cat</th>
<th data-quarto-table-cell-role="th">InPoly_FID</th>
<th data-quarto-table-cell-role="th">SmoPgnFlag</th>
<th data-quarto-table-cell-role="th">geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2023-06-15</td>
<td>JAS 2023</td>
<td>33.333333</td>
<td>Above</td>
<td>2</td>
<td>0</td>
<td>MULTIPOLYGON (((-80.35567 25.15823, -80.58782 ...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2023-06-15</td>
<td>JAS 2023</td>
<td>33.333333</td>
<td>Above</td>
<td>8</td>
<td>0</td>
<td>POLYGON ((-96.24742 43.49909, -95.75420 43.080...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>2023-06-15</td>
<td>JAS 2023</td>
<td>40.000000</td>
<td>Above</td>
<td>3</td>
<td>0</td>
<td>POLYGON ((-97.12998 36.53516, -97.48238 36.518...</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>2023-06-15</td>
<td>JAS 2023</td>
<td>33.333333</td>
<td>Below</td>
<td>5</td>
<td>0</td>
<td>MULTIPOLYGON (((-122.52575 48.32104, -122.5286...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>2023-06-15</td>
<td>JAS 2023</td>
<td>33.333333</td>
<td>Below</td>
<td>7</td>
<td>0</td>
<td>POLYGON ((-106.42924 36.60653, -106.26840 36.1...</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Upon further evaluation of the data and the information available at the NCEP (National Centers for Environmental Prediction), it has been observed that regions with an expected average precipitation (EC) are associated with equal chances for each class. This means that the probabilities for above average, below average, and average precipitation are each 33.33%. Additionally, the EC probability is always 33.33%. Therefore, for instance, any area falling within the “above” classification, the EC probability will be 33%, and the below-average probability will be equal to 100% minus the sum of the EC and above-average probabilities. This will help us defining the expected ANPP from the GrassCast scenarios.</p>
<section id="incorporate-climate-outlooks-to-grasscast-grid" class="level5">
<h5 class="anchored" data-anchor-id="incorporate-climate-outlooks-to-grasscast-grid">Incorporate Climate Outlooks to Grasscast grid</h5>
<p>The climate outlooks are represented by polygons with variable shapes. To select the ANPP corresponding to one of the three scenarios, we need to correlate it with a climate scenario at a cell grid level. This can be achieved by applying an attribute join by location and saving the information contained in the variable ‘Cat’, which specifies the expected climate anomaly, to our grid of interest.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> join_attributes_by_largest_overlap(southwest_grid_raw, precip_grid_raw):</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Overlay by intersection</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>   intersection <span class="op">=</span> gpd.overlay(southwest_grid_raw, precip_grid_raw, how<span class="op">=</span><span class="st">'intersection'</span>)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Create a new column for the area</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>   intersection[<span class="st">'area'</span>] <span class="op">=</span> intersection.geometry.area</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Sort by area so largest area is last</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>   intersection.sort_values(by<span class="op">=</span><span class="st">'area'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Drop duplicates, keep last/largest</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>   intersection.drop_duplicates(subset<span class="op">=</span><span class="st">'gridid'</span>, keep<span class="op">=</span><span class="st">'last'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>   <span class="co"># Merge Cat by Id</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>   joined <span class="op">=</span> southwest_grid_raw.merge(intersection[[<span class="st">'gridid'</span>,<span class="st">'Cat'</span>,<span class="st">'Prob'</span>]], left_on<span class="op">=</span><span class="st">'gridid'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>).clean_names()</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> joined</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>seasprcp_202306_swgrid <span class="op">=</span> join_attributes_by_largest_overlap(grasscast_aoi_grid, seasprcp_202306_raw)</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>seasprcp_202306_swgrid[[<span class="st">'gridid'</span>,<span class="st">'cat'</span>,<span class="st">'prob'</span>]].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">gridid</th>
<th data-quarto-table-cell-role="th">cat</th>
<th data-quarto-table-cell-role="th">prob</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>33406</td>
<td>Above</td>
<td>33.333333</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>33407</td>
<td>Above</td>
<td>33.333333</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>33408</td>
<td>Above</td>
<td>33.333333</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>33867</td>
<td>Above</td>
<td>33.333333</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>33868</td>
<td>Above</td>
<td>33.333333</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>To determine the most probable forecast outcome, the following subsections will incorporate climate data into each observation within the forecast dataset.</p>
</section>
<section id="southwest-2" class="level5">
<h5 class="anchored" data-anchor-id="southwest-2">Southwest</h5>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>grasscast_2023_forecast_sw <span class="op">=</span> grasscast_forecast_sw[grasscast_forecast_sw[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2023</span>]</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge based on Id</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> pd.merge(grasscast_2023_forecast_sw, seasprcp_202306_swgrid[[<span class="st">'gridid'</span>, <span class="st">'cat'</span>, <span class="st">'prob'</span>]], </span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>                     left_on<span class="op">=</span><span class="st">'gridid'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once the NOAA climate data is available in the forecast dataset, it is possible to calculate the expected forecast associated with the ANPP scenarios and determine the expected precipitation scenario for each grid cell. By incorporating the NOAA climate data, we can obtain am ANPP value based on the corresponding precipitation scenarios for each cell.</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_NPP_predict_clim(row):</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    Cat <span class="op">=</span> row[<span class="st">'cat'</span>]</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    Prob <span class="op">=</span> row[<span class="st">'prob'</span>]</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    NPP_predict_below <span class="op">=</span> row[<span class="st">'npp_predict_below'</span>]</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    NPP_predict_above <span class="op">=</span> row[<span class="st">'npp_predict_above'</span>]</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    NPP_predict_avg <span class="op">=</span> row[<span class="st">'npp_predict_avg'</span>]</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> Cat <span class="op">==</span> <span class="st">'EC'</span>:</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NPP_predict_below <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_avg <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_above <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate remaining_prob</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>        remaining_prob <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> ((Prob <span class="op">/</span> <span class="dv">100</span>) <span class="op">+</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>))</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Cat <span class="op">==</span> <span class="st">'Below'</span>:</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (NPP_predict_below <span class="op">*</span> (Prob <span class="op">/</span> <span class="dv">100</span>)) <span class="op">+</span> NPP_predict_avg <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_above <span class="op">*</span> remaining_prob</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> Cat <span class="op">==</span> <span class="st">'Above'</span>:</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (NPP_predict_above <span class="op">*</span> (Prob <span class="op">/</span> <span class="dv">100</span>)) <span class="op">+</span> NPP_predict_avg <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_below <span class="op">*</span> remaining_prob</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>merged_df[<span class="st">'npp_predict_clim'</span>] <span class="op">=</span> merged_df.<span class="bu">apply</span>(calculate_NPP_predict_clim, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="adding-climate-corrected-data-to-historical-series" class="level7">
<p class="heading">Adding climate corrected data to historical series</p>
<p>As previously mentioned, we excluded the last/current year’s forecast from the historical series, as it needs to be initially compared with the climate outlooks. Consequently, we will now add the previously calculated expected ANPP to that dataframe, which was missing one year.”</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>hist_sw[<span class="st">"year"</span>].unique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<pre><code>array([1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992,
       1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
       2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014,
       2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022])</code></pre>
</div>
</div>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the 'report_date' column to datetime if it's not</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>forecast_sw[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(forecast_sw[<span class="st">'report_date'</span>])</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter the dataframe for the last day of May and the last day of the year</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>last_day_may <span class="op">=</span> forecast_sw[forecast_sw[<span class="st">'report_date'</span>].dt.month <span class="op">==</span> <span class="dv">5</span>].groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>last_day_year <span class="op">=</span> forecast_sw.groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Group by 'year' and get the last 'report_date'</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>max_dates_per_year <span class="op">=</span> pd.concat([last_day_may, last_day_year])</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge the DataFrames</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> pd.merge(forecast_sw, max_dates_per_year, on<span class="op">=</span>[<span class="st">'year'</span>, <span class="st">'report_date'</span>])</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the month from report_date</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'month'</span>] <span class="op">=</span> pd.to_datetime(result[<span class="st">'report_date'</span>]).dt.month</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign 'spring' or 'summer' based on the month</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'season'</span>] <span class="op">=</span> result[<span class="st">'month'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">'spring'</span> <span class="cf">if</span> <span class="dv">4</span> <span class="op">&lt;=</span> x <span class="op">&lt;</span> <span class="dv">6</span> <span class="cf">else</span> <span class="st">'summer'</span>)</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign the value from npp_predict_clim to predicted_spring_anpp_lbs_ac or predicted_summer_anpp_lbs_ac</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'predicted_spring_anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[<span class="st">'npp_predict_clim'</span>] <span class="cf">if</span> row[<span class="st">'season'</span>] <span class="op">==</span> <span class="st">'spring'</span> <span class="cf">else</span> <span class="va">None</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'predicted_summer_anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[<span class="st">'npp_predict_clim'</span>] <span class="cf">if</span> row[<span class="st">'season'</span>] <span class="op">==</span> <span class="st">'summer'</span> <span class="cf">else</span> <span class="va">None</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Select the specified columns from hist_grasscast_gp</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>selected_columns_hist <span class="op">=</span> hist_sw[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"predicted_spring_anpp_lbs_ac"</span>, <span class="st">"predicted_summer_anpp_lbs_ac"</span>]]</span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>selected_columns_forecast <span class="op">=</span> result[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"predicted_spring_anpp_lbs_ac"</span>, <span class="st">"predicted_summer_anpp_lbs_ac"</span>]]</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>merged_selected_columns_forecast <span class="op">=</span> selected_columns_forecast.groupby([<span class="st">'gridid'</span>, <span class="st">'year'</span>], as_index<span class="op">=</span><span class="va">False</span>).first()</span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>df_hist_sw <span class="op">=</span> pd.concat([selected_columns_hist, merged_selected_columns_forecast], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>df_hist_sw[<span class="st">"year"</span>].unique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre><code>array([1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992,
       1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
       2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014,
       2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023])</code></pre>
</div>
</div>
</section>
</section>
<section id="great-plains-2" class="level5">
<h5 class="anchored" data-anchor-id="great-plains-2">Great Plains</h5>
<p>We will apply a similar procedure to the GP data, with slight variations due to the fact that it only contains forecast data for a single season.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>grasscast_2023_forecast_gp <span class="op">=</span> grasscast_forecast_gp[grasscast_forecast_gp[<span class="st">'year'</span>] <span class="op">==</span> <span class="dv">2023</span>]</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the 'gridid' in overlapping_ids to a set for faster lookup</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>overlapping_ids_set <span class="op">=</span> <span class="bu">set</span>(overlapping_ids[<span class="st">'gridid'</span>])</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a boolean index for rows in combined_df where 'gridid' is not in overlapping_ids_set</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>non_overlapping_index <span class="op">=</span> <span class="op">~</span>grasscast_2023_forecast_gp[<span class="st">'gridid'</span>].isin(overlapping_ids_set)</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter the combined_df using this index</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>filtered_combined_df <span class="op">=</span> grasscast_2023_forecast_gp[non_overlapping_index]</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge based on Id</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>merged_df <span class="op">=</span> pd.merge(filtered_combined_df, seasprcp_202306_swgrid[[<span class="st">'gridid'</span>, <span class="st">'cat'</span>, <span class="st">'prob'</span>]], </span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>                     left_on<span class="op">=</span><span class="st">'gridid'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply climate correlation function</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>merged_df[<span class="st">'npp_predict_clim'</span>] <span class="op">=</span> merged_df.<span class="bu">apply</span>(calculate_NPP_predict_clim, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the 'Date' column to datetime if it's not</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>forecast_gp[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(forecast_gp[<span class="st">'report_date'</span>])</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter the dataframe for the last day of the year</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>max_dates_per_year <span class="op">=</span> forecast_gp.groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Merge the DataFrames</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> pd.merge(forecast_gp, max_dates_per_year, on<span class="op">=</span>[<span class="st">'year'</span>, <span class="st">'report_date'</span>])</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign the value from npp_predict_clim to anpp_lbs_ac or predicted_summer_anpp_lbs_ac</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>result[<span class="st">'anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[<span class="st">'npp_predict_clim'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Select the specified columns from hist_grasscast_gp</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>selected_columns_hist <span class="op">=</span> hist_gp[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"anpp_lbs_ac"</span>]]</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>selected_columns_forecast <span class="op">=</span> result[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"anpp_lbs_ac"</span>]]</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>merged_selected_columns_forecast <span class="op">=</span> selected_columns_forecast.groupby([<span class="st">'gridid'</span>, <span class="st">'year'</span>], as_index<span class="op">=</span><span class="va">False</span>).first()</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>df_hist_gp <span class="op">=</span> pd.concat([selected_columns_hist, merged_selected_columns_forecast], ignore_index<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="combining-sw-and-gp-data" class="level5">
<h5 class="anchored" data-anchor-id="combining-sw-and-gp-data">Combining SW and GP data</h5>
<div class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">## CONCATENATE GP AND SW</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>df_hist <span class="op">=</span> pd.concat([df_hist_sw, df_hist_gp], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>df_forecast <span class="op">=</span> pd.concat([forecast_sw, forecast_gp], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>df_hist.to_csv(<span class="st">"../testing_data/aws/hist_data_grasscast_gp_sw.csv"</span>)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>df_forecast.to_csv(<span class="st">"../testing_data/aws/forecast_data_grasscast_gp_sw.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="market-data" class="level3">
<h3 class="anchored" data-anchor-id="market-data">Market data</h3>
<p>An interesting feature that has been added to the application is the ability to access real-time market data, specifically cattle and hay prices sourced from USDA Market News services. The USDA provides free access to the My Market News API, which is a powerful tool for developers and analysts. It offers customized market data feeds and integration capabilities for various systems or applications.</p>
<p>More information here: <a href="https://mymarketnews.ams.usda.gov/mars-api/getting-started">https://mymarketnews.ams.usda.gov/mars-api/getting-started</a></p>
<p>Before incorporating the data into the app, we conducted a preliminary API exploration to understand its contents and data structure.</p>
<section id="mymarketnews-api-exploration" class="level4">
<h4 class="anchored" data-anchor-id="mymarketnews-api-exploration">MyMarketNews API exploration</h4>
<p>MyMarketNews API allows access all range of data including updated livestoock data. For teachnical instructions and how to create an acces account visit <a href="https://mymarketnews.ams.usda.gov/mars-api/getting-started/technical-instructions">https://mymarketnews.ams.usda.gov/mars-api/getting-started/technical-instructions</a></p>
<p>Below is the function that facilitates the API connection:</p>
<div class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_data_from_marsapi(api_key, endpoint):</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    base_url <span class="op">=</span> <span class="st">"https://marsapi.ams.usda.gov"</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    response <span class="op">=</span> requests.get(base_url <span class="op">+</span> endpoint, auth<span class="op">=</span>(api_key, <span class="st">''</span>))</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> response.status_code <span class="op">==</span> <span class="dv">200</span>:</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> response.json()</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>        response.raise_for_status()</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>api_key <span class="op">=</span> <span class="bu">open</span>(<span class="st">"foodsight-app/.mmn_api_token"</span>).read() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s explore the market types included in the API</p>
<div class="cell" data-execution_count="47">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>endpoint <span class="op">=</span> <span class="st">"/services/v1.2/marketTypes"</span> </span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> get_data_from_marsapi(api_key, endpoint)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>pd.DataFrame(data).head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="47">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">market_type_id</th>
<th data-quarto-table-cell-role="th">market_type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1029</td>
<td>Auction Hay</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1000</td>
<td>Auction Livestock</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1013</td>
<td>Auction Livestock (Board Sale)</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1010</td>
<td>Auction Livestock (Imported)</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1012</td>
<td>Auction Livestock (Special Graded)</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>We are interested in Auction Livestock with id 1000. Let’s explore what markets are included.</p>
<div class="cell" data-execution_count="60">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>endpoint <span class="op">=</span> <span class="st">"/services/v1.2/marketTypes/1000"</span> <span class="co"># 1000 is the market type ID for Auction Livestock</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> get_data_from_marsapi(api_key, endpoint)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"columns:"</span>, df.columns)</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">""</span>)</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"markets: "</span>,pd.Series([item <span class="cf">for</span> sublist <span class="kw">in</span> df[<span class="st">'markets'</span>] <span class="cf">for</span> item <span class="kw">in</span> sublist]).unique()[<span class="dv">0</span>:<span class="dv">9</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>columns: Index(['slug_id', 'slug_name', 'report_title', 'report_date', 'published_date',
       'report_status', 'markets', 'market_types', 'offices',
       'hasCorrectionsInLastThreeDays', 'sectionNames'],
      dtype='object')

markets:  ['Unionville Livestock Market LLC' 'Joplin Regional Stockyards'
 'New Cambria Livestock Market' 'Ozarks Regional Stockyards'
 'Green City Livestock Auction' 'Springfield Livestock Marketing Center'
 'Oklahoma National Stockyards Market' 'OKC West Livestock Market'
 'Columbia Livestock Market']</code></pre>
</div>
</div>
<p>We can search for a specific market and retrieve its ID to access cattle data for that market.</p>
<div class="cell" data-execution_count="53">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>df[df[<span class="st">'markets'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">"Cattlemen's Livestock Auction - Belen, NM"</span> <span class="kw">in</span> x)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="53">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">slug_id</th>
<th data-quarto-table-cell-role="th">slug_name</th>
<th data-quarto-table-cell-role="th">report_title</th>
<th data-quarto-table-cell-role="th">report_date</th>
<th data-quarto-table-cell-role="th">published_date</th>
<th data-quarto-table-cell-role="th">report_status</th>
<th data-quarto-table-cell-role="th">markets</th>
<th data-quarto-table-cell-role="th">market_types</th>
<th data-quarto-table-cell-role="th">offices</th>
<th data-quarto-table-cell-role="th">hasCorrectionsInLastThreeDays</th>
<th data-quarto-table-cell-role="th">sectionNames</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">35</td>
<td>1783</td>
<td>AMS_1783</td>
<td>Cattlemen's Livestock Auction - Belen, NM</td>
<td>01/26/2024</td>
<td>01/26/2024 19:53:39</td>
<td>Final</td>
<td>[Cattlemen's Livestock Auction - Belen, NM]</td>
<td>[Auction Livestock]</td>
<td>[Portales, NM]</td>
<td>False</td>
<td>[]</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>By using the slug_id for Cattlemen’s Livestock Auction in Belen, NM, we can access the available data for cattle markets.</p>
<div class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>endpoint <span class="op">=</span> <span class="st">"/services/v1.2/reports/1783"</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> get_data_from_marsapi(api_key, endpoint)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data[<span class="st">'results'</span>])</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>df.columns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="65">
<pre><code>Index(['report_date', 'report_begin_date', 'report_end_date', 'published_date',
       'office_name', 'office_state', 'office_city', 'office_code',
       'market_type', 'market_type_category', 'market_location_name',
       'market_location_state', 'market_location_city', 'slug_id', 'slug_name',
       'report_title', 'group', 'category', 'commodity', 'class', 'frame',
       'muscle_grade', 'quality_grade_name', 'lot_desc', 'freight',
       'price_unit', 'age', 'pregnancy_stage', 'weight_collect',
       'offspring_weight_est', 'dressing', 'yield_grade', 'head_count',
       'avg_weight_min', 'avg_weight_max', 'avg_weight', 'avg_price_min',
       'avg_price_max', 'avg_price', 'weight_break_low', 'weight_break_high',
       'receipts', 'receipts_week_ago', 'receipts_year_ago',
       'comments_commodity', 'report_narrative', 'final_ind'],
      dtype='object')</code></pre>
</div>
</div>
<p>We can also browse through the accessed object to explore the available categories among some of those variables.</p>
<div class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"market_location_name: "</span>,df[<span class="st">"market_location_name"</span>].unique())</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"commodity: "</span>,df[<span class="st">"commodity"</span>].unique())</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"class: "</span>,df[<span class="st">"class"</span>].unique())</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"frame: "</span>,df[<span class="st">"frame"</span>].unique())</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"muscle_grade: "</span>,df[<span class="st">"muscle_grade"</span>].unique())</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"quality_grade_name: "</span>,df[<span class="st">"quality_grade_name"</span>].unique())</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"lot_desc: "</span>,df[<span class="st">"lot_desc"</span>].unique())</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"freight: "</span>,df[<span class="st">"freight"</span>].unique())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>market_location_name:  ["Cattlemen's Livestock Auction - Belen, NM"]
commodity:  ['Feeder Cattle' 'Slaughter Cattle' 'Replacement Cattle']
class:  ['Heifers' 'Steers' 'Bulls' 'Stock Cows' 'Bred Cows' 'Cow-Calf Pairs'
 'Cows' 'Bred Heifers' 'Dairy Steers' 'Dairy Heifers' 'Heifer Pairs']
frame:  ['Medium and Large' 'Small' 'N/A' 'Medium' 'Large' 'Small and Medium']
muscle_grade:  ['1-2' '2' '1' '4' 'N/A' '2-3' '3' '3-4']
quality_grade_name:  [None 'N/A' 'Lean 85-90%' 'Boner 80-85%' 'Breaker 75-80%'
 'Premium White 65-75%']
lot_desc:  ['None' 'Value Added' 'Unweaned' 'Return to Feed' 'Source/Aged' 'Natural'
 'Light Weight' 'Fancy' 'Full' 'Mexican Origin' 'Fleshy' 'Thin Fleshed'
 'Registered' 'Gaunt' 'Replacement']
freight:  ['F.O.B.']</code></pre>
</div>
</div>
<p>As we can see this has pulled all the auction livestock data for our market of interest. We can set a more specific query to pull the data. For instance, we could extract the data applying the same filters as in the historical data represented in the App. This would allow us to compare the last records on the historical series with the first records available in the API.</p>
<div class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>endpoint <span class="op">=</span> <span class="st">"/services/v1.2/reports/1783?q=commodity=Feeder Cattle;class=Heifers"</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> get_data_from_marsapi(api_key, endpoint)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data[<span class="st">'results'</span>])</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"commodity: "</span>,df[<span class="st">"commodity"</span>].unique())</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"class: "</span>,df[<span class="st">"class"</span>].unique())</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"frame: "</span>,df[<span class="st">"frame"</span>].unique())</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"muscle_grade: "</span>,df[<span class="st">"muscle_grade"</span>].unique())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>commodity:  ['Feeder Cattle']
class:  ['Heifers']
frame:  ['Medium and Large' 'Small' 'Medium' 'Small and Medium' 'Large']
muscle_grade:  ['2' '1' '1-2' '4' '2-3' '3-4' '3']</code></pre>
</div>
</div>
<p>Having a clear understanding of how the data is structured and how to retrieve it, we can now prepare the necessary data and code to be included in the app for on-demand data retrieval.</p>
<p>For additional learning resources, please visit the link at <a href="https://mymarketnews.ams.usda.gov/mymarketnews-api/examples">https://mymarketnews.ams.usda.gov/mymarketnews-api/examples</a>.</p>
</section>
<section id="listing-available-markets-for-cattle-and-hay" class="level4">
<h4 class="anchored" data-anchor-id="listing-available-markets-for-cattle-and-hay">Listing available markets for Cattle and Hay</h4>
<p>The previous exploration provided us with insights on how to craft customized queries and retrieve specific market data. Given the design of the backend code, we will need a list of cattle markets from which we want to extract the relevant data. To achieve this, we must assess the characteristics of the markets and filter out those that do not align with our interests.</p>
<div class="cell" data-execution_count="71">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>endpoint <span class="op">=</span> <span class="st">"/services/v1.2/marketTypes/1000"</span> <span class="co"># 1000 is the market type ID for Auction Livestock</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> get_data_from_marsapi(api_key, endpoint)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>market_values <span class="op">=</span> [(item[<span class="st">'slug_id'</span>], item[<span class="st">'markets'</span>][<span class="dv">0</span>]) <span class="cf">for</span> item <span class="kw">in</span> data <span class="cf">if</span> <span class="st">'markets'</span> <span class="kw">in</span> item <span class="kw">and</span> item[<span class="st">'markets'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="72">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> enrich_market_data_to_json(api_key, market_values):</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    enriched_data <span class="op">=</span> []</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base endpoint for fetching detailed market data</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    base_endpoint <span class="op">=</span> <span class="st">"/services/v1.2/reports/"</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> market_id, market_name <span class="kw">in</span> market_values:</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Construct the specific endpoint using market_id</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>        endpoint <span class="op">=</span> base_endpoint <span class="op">+</span> <span class="bu">str</span>(market_id)</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Fetch data from the API</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> get_data_from_marsapi(api_key, endpoint)</span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract the state and city details</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>        market_location_state <span class="op">=</span> data[<span class="st">'results'</span>][<span class="dv">0</span>][<span class="st">'market_location_state'</span>]</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>        market_location_city <span class="op">=</span> data[<span class="st">'results'</span>][<span class="dv">0</span>][<span class="st">'market_location_city'</span>]</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a dictionary for the market</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>        market_dict <span class="op">=</span> {</span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>            <span class="st">"slug_id"</span>: market_id,</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">"market_location_name"</span>: market_name,</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>            <span class="st">"market_location_state"</span>: market_location_state,</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>            <span class="st">"market_location_city"</span>: market_location_city</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Append the dictionary to enriched data</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>        enriched_data.append(market_dict)</span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the enriched data to JSON format</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>    json_data <span class="op">=</span> json.dumps(enriched_data, indent<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> json_data</span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>json_result <span class="op">=</span> enrich_market_data_to_json(api_key, market_values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we execute the above function, we will generate a JSON containing the available markets extracted from the ‘market types’ section of the API.</p>
<p>There is a total of 334 available markets for livestock. However, do all of these markets have auction data for cattle, specifically in the heifer and steer varieties? To determine this, we will extract all the data of interest and explore it. The following code accesses the API for Feeder Cattle in the varieties of Heifer and Steer.</p>
<div class="cell" data-execution_count="76">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_data_and_save_to_csv(api_key, markets_list, csv_filename<span class="op">=</span><span class="st">'extracted_data.csv'</span>):    </span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    data_list <span class="op">=</span> []</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> market <span class="kw">in</span> markets_list:</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>        slug_id <span class="op">=</span> market[<span class="st">'slug_id'</span>]</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>        endpoint <span class="op">=</span> <span class="ss">f"/services/v1.2/reports/</span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss">?q=commodity=Feeder Cattle;class=Heifers,Steers"</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>            data <span class="op">=</span> get_data_from_marsapi(api_key, endpoint)</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>            results <span class="op">=</span> data.get(<span class="st">'results'</span>, [])</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>            data_list.extend(results)</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Successfully retrieved data for slug_id </span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss">."</span>)</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Error fetching data for slug_id </span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame(data_list)</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>    df.to_csv(csv_filename, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Data saved to </span><span class="sc">{</span>csv_filename<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>extract_data_and_save_to_csv(api_key, markets_list_raw, csv_filename<span class="op">=</span><span class="st">'extracted_data.csv'</span>)</span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>extracted_data <span class="op">=</span> pd.read_csv(<span class="st">'extracted_data.csv'</span>)</span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>unique_id <span class="op">=</span> extracted_data[<span class="st">'slug_id'</span>].unique().tolist()</span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>str_values <span class="op">=</span> [<span class="bu">str</span>(val) <span class="cf">for</span> val <span class="kw">in</span> unique_id]</span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(str_values)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we can observe from running the new function, there are fewer markets with that specific information. Some of the missing markets may trade other types of livestock such as bulls, goats, sheep, etc. Let’s proceed to retain only those 278 markets of interest from our markets_list.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>filtered_locations <span class="op">=</span> [entry <span class="cf">for</span> entry <span class="kw">in</span> markets_list_raw <span class="cf">if</span> entry[<span class="st">'slug_id'</span>] <span class="kw">in</span> str_values]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Upon further evaluation, we have noticed that some entries are missing the state and city information. With the following function, we will utilize the associated information from the ‘market_location_name’ to populate the empty ones.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_location_info(locations):</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a dictionary with name as key and state, city as values</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    location_info <span class="op">=</span> {}</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> entry <span class="kw">in</span> locations:</span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>        name <span class="op">=</span> entry[<span class="st">'market_location_name'</span>]</span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> entry[<span class="st">'market_location_state'</span>]</span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>        city <span class="op">=</span> entry[<span class="st">'market_location_city'</span>]</span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> state <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> city <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>            location_info[name] <span class="op">=</span> {<span class="st">'state'</span>: state, <span class="st">'city'</span>: city}</span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate a new list with updated entries</span></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    updated_locations <span class="op">=</span> []</span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> entry <span class="kw">in</span> locations:</span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>        name <span class="op">=</span> entry[<span class="st">'market_location_name'</span>]</span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> entry[<span class="st">'market_location_state'</span>] <span class="kw">is</span> <span class="va">None</span> <span class="kw">and</span> entry[<span class="st">'market_location_city'</span>] <span class="kw">is</span> <span class="va">None</span> <span class="kw">and</span> name <span class="kw">in</span> location_info:</span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>            entry[<span class="st">'market_location_state'</span>] <span class="op">=</span> location_info[name][<span class="st">'state'</span>]</span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>            entry[<span class="st">'market_location_city'</span>] <span class="op">=</span> location_info[name][<span class="st">'city'</span>]</span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>        updated_locations.append(entry)</span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> updated_locations</span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>updated_locations_list <span class="op">=</span> update_location_info(filtered_locations)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Additionally, it’s worth noting that some markets only have a few observations, making it impossible to construct a representative time series. In the following evaluation, we will identify markets with fewer than 10 observations and exclude them. Additionally, we will discard markets that lack data for the past year.”</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>mean_values <span class="op">=</span> extracted_data.groupby([<span class="st">'slug_id'</span>,<span class="st">'market_location_name'</span>, <span class="st">'report_date'</span>])[<span class="st">'avg_price'</span>].mean().reset_index()</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert 'report_date' to datetime format</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>mean_values[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(mean_values[<span class="st">'report_date'</span>])</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Count the number of observations for each slug_id</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>slug_counts <span class="op">=</span> mean_values[<span class="st">'slug_id'</span>].value_counts()</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the slug_id values that have less than 10 observations</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>less_than_10 <span class="op">=</span> slug_counts[slug_counts <span class="op">&lt;</span> <span class="dv">10</span>].index.tolist()</span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the date range for 2023</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>start_2023 <span class="op">=</span> pd.Timestamp(<span class="st">'2023-01-01'</span>)</span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>end_2023 <span class="op">=</span> pd.Timestamp(<span class="st">'2023-12-31'</span>)</span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the slug_ids that have data for 2023</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>slug_ids_with_data_2023 <span class="op">=</span> mean_values[(mean_values[<span class="st">'report_date'</span>] <span class="op">&gt;=</span> start_2023) <span class="op">&amp;</span> (mean_values[<span class="st">'report_date'</span>] <span class="op">&lt;=</span> end_2023)][<span class="st">'slug_id'</span>].unique()</span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Get all unique slug_ids from the dataset</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>all_slug_ids <span class="op">=</span> mean_values[<span class="st">'slug_id'</span>].unique()</span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Find slug_ids that do not have any dates for 2023</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>missing_2023 <span class="op">=</span> [slug_id <span class="cf">for</span> slug_id <span class="kw">in</span> all_slug_ids <span class="cf">if</span> slug_id <span class="kw">not</span> <span class="kw">in</span> slug_ids_with_data_2023]</span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert lists to strings</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a>less_than_10_strings <span class="op">=</span> [<span class="bu">str</span>(item) <span class="cf">for</span> item <span class="kw">in</span> less_than_10]</span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a>missing_2023_strings <span class="op">=</span> [<span class="bu">str</span>(item) <span class="cf">for</span> item <span class="kw">in</span> missing_2023]</span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Slug_ids with less than 10 observations:"</span>, less_than_10_strings)</span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Slug_ids with no dates for 2023:"</span>, missing_2023_strings)</span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine lists and get unique values</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a>combined_unique <span class="op">=</span> <span class="bu">list</span>(<span class="bu">set</span>(less_than_10_strings <span class="op">+</span> missing_2023_strings))</span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert the combined list to strings</span></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a>combined_strings <span class="op">=</span> [<span class="bu">str</span>(item) <span class="cf">for</span> item <span class="kw">in</span> combined_unique]</span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(combined_strings), <span class="st">"Combined unique slug_ids:"</span>, combined_strings)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Slug_ids with less than 10 observations: ['1974', '2038', '1883', '1843', '2018', '3676', '1977', '1978', '1971', '1779', '3692', '2379', '1898', '2102', '1823', '1975', '1824', '2110']
Slug_ids with no dates for 2023: ['1423', '1512', '1779', '1809', '1818', '1820', '1823', '1824', '1859', '1883', '1904', '1931', '1952', '1960', '1970', '1971', '1975', '1977', '1978', '1993', '1994', '2010', '2012', '2018', '2038', '2054', '2060', '2102', '2110', '2161', '2214', '2379']
37 Combined unique slug_ids: ['1843', '1931', '2018', '1952', '2010', '3676', '3692', '1904', '1823', '1993', '2054', '1978', '2102', '2161', '1859', '2038', '2214', '1423', '1974', '1809', '1994', '1824', '1818', '2110', '1512', '2379', '1779', '1977', '1970', '1898', '1820', '1883', '2012', '1960', '1975', '1971', '2060']</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>filtered_10 <span class="op">=</span> [entry <span class="cf">for</span> entry <span class="kw">in</span> updated_locations_list <span class="cf">if</span> entry[<span class="st">'slug_id'</span>] <span class="kw">not</span> <span class="kw">in</span> combined_strings]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>241</code></pre>
</div>
</div>
<p>The subsequent filtering process leaves us with 241 available markets, which will constitute the final list of cattle markets. However, before finalizing this list, we will make one last modification by removing duplicate market entries and renaming them distinctively to access their information using the app.</p>
<div class="cell" data-execution_count="77">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_duplicate_names(locations):</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count occurrences of each unique name, state, city combination</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    count_map <span class="op">=</span> {}</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> entry <span class="kw">in</span> locations:</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>        name <span class="op">=</span> entry[<span class="st">'market_location_name'</span>]</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> entry[<span class="st">'market_location_state'</span>]</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>        city <span class="op">=</span> entry[<span class="st">'market_location_city'</span>]</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>        key <span class="op">=</span> (name, state, city)</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>        count_map[key] <span class="op">=</span> count_map.get(key, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a dictionary to keep track of current count for each duplicate entry</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>    current_count_map <span class="op">=</span> {}</span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> entry <span class="kw">in</span> locations:</span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>        name <span class="op">=</span> entry[<span class="st">'market_location_name'</span>]</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>        state <span class="op">=</span> entry[<span class="st">'market_location_state'</span>]</span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>        city <span class="op">=</span> entry[<span class="st">'market_location_city'</span>]</span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>        key <span class="op">=</span> (name, state, city)</span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> count_map[key] <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a>            current_count_map[key] <span class="op">=</span> current_count_map.get(key, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a>            entry[<span class="st">'market_location_name'</span>] <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>current_count_map[key]<span class="sc">}</span><span class="ss">)"</span></span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> locations</span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-27"><a href="#cb75-27" aria-hidden="true" tabindex="-1"></a>final_updated_list <span class="op">=</span> update_duplicate_names(filtered_10)</span>
<span id="cb75-28"><a href="#cb75-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-29"><a href="#cb75-29" aria-hidden="true" tabindex="-1"></a>json_data <span class="op">=</span> json.dumps(final_updated_list, indent<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb75-30"><a href="#cb75-30" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"cattle_markets.json"</span>, <span class="st">"w"</span>) <span class="im">as</span> outfile:</span>
<span id="cb75-31"><a href="#cb75-31" aria-hidden="true" tabindex="-1"></a>        outfile.write(json_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With this step completed, we now have the final list of Cattle markets containing information on ‘slug_id,’ ‘market_location_name,’ ‘market_location_state,’ and ‘market_location_city.’ This list corresponds to the ‘cattle_markets.json’ file, which will be used within the app. The same procedure with minimal modifications can be applied to any other market for the data of interest. This was done for the Hay market as well, and the resulting list is stored as ‘hay_markets.json’ to be used in the app.</p>
</section>
</section>
</section>
<section id="lambda-functions" class="level2">
<h2 class="anchored" data-anchor-id="lambda-functions">Lambda Functions</h2>
<p>The data section highlights the process by which the original datasets can be accessed and prepared for use within the application. However, some of these datasets need regular updates to reflect new forecasts or market updates. On one hand, the absence of a functional GrassCast API from which to fetch structured data makes it inconvenient to obtain newly released forecast values. Therefore, the application is fed by Lambda functions that web scrape the necessary resources from GrassCast and NOAA CPC websites and process them to calculate and structure the data in a readable format according to the app’s design.</p>
<p>Similarly, while market information can be directly accessed within the app by integrating the API into the backend code, the way in which the pulled data is structured requires some data wrangling, which, in some cases, cannot be done in real-time by querying from the API. Consequently, for the top markets and weight vs.&nbsp;price representations on the Markets page, an additional Lambda function has been implemented to fetch daily data and structure it in a readable format for these two data visualizations.</p>
<p>In the following sections, we will present the workflow code included in these Lambda functions designed around the app and the associated AWS services.</p>
<section id="forecast-data-updates" class="level3">
<h3 class="anchored" data-anchor-id="forecast-data-updates">Forecast Data Updates</h3>
<p>The diagram below summarizes the processes associated with data access and web scraping from NOAA and GrassCast websites, as well as the transformations conducted to generate the final datasets that feed into the app. Two Lambda Functions have been implemented for this purpose. The processes associated with the Forecast Lambda Function, as depicted in the diagram, are run independently for the GP and SW regions’ datasets. These processes include some minor differences, as described in the Data section.</p>
<p>Due to the considerable size of the dependencies involved, both functions have been packaged as Docker images. The deployment was carried out using AWS CDK and CLI, and you can access the files and folder structure in the “clim-forecast_updates-aws-lambda-docker” folder within the repository.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diagrams <span class="im">import</span> Diagram, Cluster, Edge</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diagrams.aws.compute <span class="im">import</span> Lambda, EB</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diagrams.aws.storage <span class="im">import</span> S3</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diagrams.aws.integration <span class="im">import</span> Eventbridge</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diagrams.aws.general <span class="im">import</span> InternetGateway</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diagrams.digitalocean.database <span class="im">import</span> DbaasPrimary, DbaasStandby</span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>graph_attrs <span class="op">=</span> {</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">#  "splines": "curved",</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">"pad"</span>: <span class="st">"1"</span>,</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>    <span class="st">"nodesep"</span>: <span class="st">"0.50"</span>,</span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ranksep"</span>: <span class="st">"0.75"</span>,</span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"fontname"</span>: <span class="st">"Sans-Serif"</span>,</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"fontsize"</span>: <span class="st">"12"</span>,</span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"fontcolor"</span>: <span class="st">"#000000"</span>,</span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"size"</span>: <span class="st">"6,6"</span>,</span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">"dpi"</span>: <span class="st">"200"</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> Diagram(<span class="st">"Grasscast Data Processing"</span>, show<span class="op">=</span><span class="va">False</span>, direction<span class="op">=</span><span class="st">"LR"</span>, graph_attr<span class="op">=</span>graph_attrs) <span class="im">as</span> diag:</span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a>    noaa_web <span class="op">=</span> InternetGateway(<span class="st">"NOAA website"</span>)</span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a>    aoi_grid <span class="op">=</span> S3(<span class="st">"AOI Grid"</span>)</span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Grasscast web SW and GP data</span></span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a>    grasscast_web_sw <span class="op">=</span> InternetGateway(<span class="st">"Grasscast website"</span>)</span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># S3 and Database storage</span></span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a>    forecast_comb <span class="op">=</span> S3(<span class="st">"Forecast comb."</span>)</span>
<span id="cb76-29"><a href="#cb76-29" aria-hidden="true" tabindex="-1"></a>    hist_comb <span class="op">=</span> S3(<span class="st">"Hist. comb."</span>)</span>
<span id="cb76-30"><a href="#cb76-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-31"><a href="#cb76-31" aria-hidden="true" tabindex="-1"></a>    app <span class="op">=</span> EB(<span class="st">"ElasticBeanstalk"</span>)</span>
<span id="cb76-32"><a href="#cb76-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-33"><a href="#cb76-33" aria-hidden="true" tabindex="-1"></a>    eb1 <span class="op">=</span> Eventbridge(<span class="st">"Daily trigger</span><span class="ch">\n</span><span class="st">(April-September)"</span>)</span>
<span id="cb76-34"><a href="#cb76-34" aria-hidden="true" tabindex="-1"></a>    eb2 <span class="op">=</span> Eventbridge(<span class="st">"Montly trigger</span><span class="ch">\n</span><span class="st">(April-July)"</span>)</span>
<span id="cb76-35"><a href="#cb76-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-36"><a href="#cb76-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SW Data Processing Cluster</span></span>
<span id="cb76-37"><a href="#cb76-37" aria-hidden="true" tabindex="-1"></a>    sw_hist <span class="op">=</span> S3(<span class="st">"SW/GP Hist."</span>)</span>
<span id="cb76-38"><a href="#cb76-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-39"><a href="#cb76-39" aria-hidden="true" tabindex="-1"></a>    forecast_climate_correlated_sw <span class="op">=</span> S3(<span class="st">"Forecast climate</span><span class="ch">\n</span><span class="st">correlated SW/GP"</span>)</span>
<span id="cb76-40"><a href="#cb76-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-41"><a href="#cb76-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> Cluster(<span class="st">"Forecast Lambda Function"</span>):</span>
<span id="cb76-42"><a href="#cb76-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-43"><a href="#cb76-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> Cluster(<span class="st">"Hist. Data Processing"</span>):</span>
<span id="cb76-44"><a href="#cb76-44" aria-hidden="true" tabindex="-1"></a>            all_hist_series_ex_last_year_sw <span class="op">=</span> Lambda(<span class="st">"Excluding</span><span class="ch">\n</span><span class="st">last year</span><span class="ch">\n</span><span class="st">from SW/GP</span><span class="ch">\n</span><span class="st">hist. series"</span>)</span>
<span id="cb76-45"><a href="#cb76-45" aria-hidden="true" tabindex="-1"></a>            last_forecast_cor_val_sw <span class="op">=</span> Lambda(<span class="st">"Extracting last</span><span class="ch">\n</span><span class="st">SW/GP forecast</span><span class="ch">\n</span><span class="st">cor. value"</span>)</span>
<span id="cb76-46"><a href="#cb76-46" aria-hidden="true" tabindex="-1"></a>            updated_hist_sw <span class="op">=</span> DbaasPrimary(<span class="st">"Updated hist</span><span class="ch">\n</span><span class="st">SW/GP"</span>)</span>
<span id="cb76-47"><a href="#cb76-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> Cluster(<span class="st">"Forecast Data Processing"</span>):</span>
<span id="cb76-48"><a href="#cb76-48" aria-hidden="true" tabindex="-1"></a>            most_recent_sw_forecast_val <span class="op">=</span> DbaasPrimary(<span class="st">"Most recent</span><span class="ch">\n</span><span class="st">SW/GP forecast</span><span class="ch">\n</span><span class="st">value"</span>)</span>
<span id="cb76-49"><a href="#cb76-49" aria-hidden="true" tabindex="-1"></a>            webscraping_sw_data <span class="op">=</span> Lambda(<span class="st">"Webscraping</span><span class="ch">\n</span><span class="st">SW/GP data"</span>)</span>
<span id="cb76-50"><a href="#cb76-50" aria-hidden="true" tabindex="-1"></a>            processing_updated_forecast_sw <span class="op">=</span> Lambda(<span class="st">"Processing updated</span><span class="ch">\n</span><span class="st">SW/GP forecast"</span>)</span>
<span id="cb76-51"><a href="#cb76-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-52"><a href="#cb76-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb76-53"><a href="#cb76-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-54"><a href="#cb76-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># NOAA Data Processing Cluster</span></span>
<span id="cb76-55"><a href="#cb76-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> Cluster(<span class="st">"Climate Lambda Function"</span>):</span>
<span id="cb76-56"><a href="#cb76-56" aria-hidden="true" tabindex="-1"></a>        webscraping_climate_outlook <span class="op">=</span> Lambda(<span class="st">"Webscraping</span><span class="ch">\n</span><span class="st">climate outlook"</span>)</span>
<span id="cb76-57"><a href="#cb76-57" aria-hidden="true" tabindex="-1"></a>        most_recent_climate_outlook <span class="op">=</span> DbaasPrimary(<span class="st">"Most recent</span><span class="ch">\n</span><span class="st">climate outlook"</span>)</span>
<span id="cb76-58"><a href="#cb76-58" aria-hidden="true" tabindex="-1"></a>        processing_clim_data <span class="op">=</span> Lambda(<span class="st">"Structuring</span><span class="ch">\n</span><span class="st">climate data"</span>)</span>
<span id="cb76-59"><a href="#cb76-59" aria-hidden="true" tabindex="-1"></a>        climate_grid <span class="op">=</span> DbaasStandby(<span class="st">"Climate</span><span class="ch">\n</span><span class="st">Grid"</span>)</span>
<span id="cb76-60"><a href="#cb76-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-61"><a href="#cb76-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Connecting nodes within the NOAA Data Processing Cluster</span></span>
<span id="cb76-62"><a href="#cb76-62" aria-hidden="true" tabindex="-1"></a>        aoi_grid <span class="op">&gt;&gt;</span> processing_clim_data </span>
<span id="cb76-63"><a href="#cb76-63" aria-hidden="true" tabindex="-1"></a>        noaa_web <span class="op">&gt;&gt;</span> eb2 <span class="op">&gt;&gt;</span> webscraping_climate_outlook <span class="op">&gt;&gt;</span> most_recent_climate_outlook <span class="op">&gt;&gt;</span> processing_clim_data <span class="op">&gt;&gt;</span> climate_grid</span>
<span id="cb76-64"><a href="#cb76-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-65"><a href="#cb76-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Connecting the other nodes</span></span>
<span id="cb76-66"><a href="#cb76-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Grasscast web to webscraping</span></span>
<span id="cb76-67"><a href="#cb76-67" aria-hidden="true" tabindex="-1"></a>    grasscast_web_sw <span class="op">&gt;&gt;</span> eb1 <span class="op">&gt;&gt;</span> webscraping_sw_data <span class="op">&gt;&gt;</span> processing_updated_forecast_sw <span class="op">&gt;&gt;</span> most_recent_sw_forecast_val <span class="op">&gt;&gt;</span> forecast_climate_correlated_sw <span class="op">&gt;&gt;</span> forecast_comb <span class="op">&gt;&gt;</span> app</span>
<span id="cb76-68"><a href="#cb76-68" aria-hidden="true" tabindex="-1"></a>    forecast_climate_correlated_sw <span class="op">&gt;&gt;</span> forecast_comb</span>
<span id="cb76-69"><a href="#cb76-69" aria-hidden="true" tabindex="-1"></a>    most_recent_sw_forecast_val <span class="op">&gt;&gt;</span> forecast_climate_correlated_sw</span>
<span id="cb76-70"><a href="#cb76-70" aria-hidden="true" tabindex="-1"></a>    updated_hist_sw <span class="op">&gt;&gt;</span> sw_hist</span>
<span id="cb76-71"><a href="#cb76-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Climate grid to forecast correlation</span></span>
<span id="cb76-72"><a href="#cb76-72" aria-hidden="true" tabindex="-1"></a>    climate_grid <span class="op">&gt;&gt;</span> forecast_climate_correlated_sw</span>
<span id="cb76-73"><a href="#cb76-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-74"><a href="#cb76-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Processing historical data</span></span>
<span id="cb76-75"><a href="#cb76-75" aria-hidden="true" tabindex="-1"></a>    forecast_climate_correlated_sw <span class="op">&gt;&gt;</span> last_forecast_cor_val_sw <span class="op">&gt;&gt;</span> updated_hist_sw</span>
<span id="cb76-76"><a href="#cb76-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-77"><a href="#cb76-77" aria-hidden="true" tabindex="-1"></a>    sw_hist <span class="op">&gt;&gt;</span> all_hist_series_ex_last_year_sw <span class="op">&gt;&gt;</span> updated_hist_sw <span class="op">&gt;&gt;</span> hist_comb <span class="op">&gt;&gt;</span> app</span>
<span id="cb76-78"><a href="#cb76-78" aria-hidden="true" tabindex="-1"></a>    updated_hist_sw <span class="op">&gt;&gt;</span> hist_comb</span>
<span id="cb76-79"><a href="#cb76-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-80"><a href="#cb76-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-81"><a href="#cb76-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-82"><a href="#cb76-82" aria-hidden="true" tabindex="-1"></a>diag</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<p><img src="foodsight_notebook_files/figure-html/cell-92-output-1.png" class="img-fluid"></p>
</div>
</div>
<section id="climate-lambda-function" class="level4">
<h4 class="anchored" data-anchor-id="climate-lambda-function">Climate Lambda Function</h4>
<p>This function accesses NOAA’s long-range precipitation outlook records, which are available at <a href="https://ftp.cpc.ncep.noaa.gov/GIS/us_tempprcpfcst/">https://ftp.cpc.ncep.noaa.gov/GIS/us_tempprcpfcst/</a>, and stores them in S3 storage services as a shapefile. It then reads the GrassCast grid and joins the outlooks’ attributes by finding the largest overlap within each cell of the grid. The resulting file contains a dataset that includes each cell’s ID, its association with a climate scenario, and the associated probability. This dataset will be further used in the Forecast Lambda Function.</p>
<p>Below is the code implemented for this purpose. Despite the final Lambda functions including the handlers and Lambda output structure, this code performs the same tasks as the ones running on AWS. Please note that it is already associated with the S3 bucket from which the app feeds. If you do not have access to S3, you can substitute the paths with your folders of interest and run it locally.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lambda_function():</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Importing Libraries ------------------ #</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> boto3</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> json</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> sys</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> os</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> io</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> requests</span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> zipfile</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> janitor</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> datetime <span class="im">import</span> datetime</span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> io <span class="im">import</span> BytesIO</span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> botocore.exceptions <span class="im">import</span> NoCredentialsError</span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ AWS S3 parameters ------------------ #</span></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a>    s3 <span class="op">=</span> boto3.client(<span class="st">'s3'</span>)  <span class="co"># Initializing Amazon S3 client</span></span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a>    bucket_name <span class="op">=</span> <span class="st">'foodsight-lambda'</span></span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a>    key_path_grasscast_grid_read <span class="op">=</span> <span class="st">'spatial_data/grasscast_aoi_grid.geojson'</span></span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a>    key_path_overlapping_gridids_read <span class="op">=</span> <span class="st">'spatial_data/overlapping_gridids.json'</span></span>
<span id="cb77-25"><a href="#cb77-25" aria-hidden="true" tabindex="-1"></a>    key_path_seasprcp_data_read <span class="op">=</span> <span class="st">'spatial_data/seasprcp_data'</span></span>
<span id="cb77-26"><a href="#cb77-26" aria-hidden="true" tabindex="-1"></a>    key_path_seasprcp_grid_read <span class="op">=</span> <span class="st">'spatial_data/seasprcp_grid.csv'</span></span>
<span id="cb77-27"><a href="#cb77-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-28"><a href="#cb77-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-29"><a href="#cb77-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Define functions ------------------#</span></span>
<span id="cb77-30"><a href="#cb77-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Defining helper functions..."</span>)</span>
<span id="cb77-31"><a href="#cb77-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-32"><a href="#cb77-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Read/write functions:</span></span>
<span id="cb77-33"><a href="#cb77-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-34"><a href="#cb77-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to read a JSON file from S3</span></span>
<span id="cb77-35"><a href="#cb77-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read_json_from_s3(bucket, key):</span>
<span id="cb77-36"><a href="#cb77-36" aria-hidden="true" tabindex="-1"></a>        response <span class="op">=</span> s3.get_object(Bucket<span class="op">=</span>bucket, Key<span class="op">=</span>key)</span>
<span id="cb77-37"><a href="#cb77-37" aria-hidden="true" tabindex="-1"></a>        json_obj <span class="op">=</span> response[<span class="st">'Body'</span>].read().decode(<span class="st">'utf-8'</span>)</span>
<span id="cb77-38"><a href="#cb77-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pd.DataFrame(json.loads(json_obj))</span>
<span id="cb77-39"><a href="#cb77-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-40"><a href="#cb77-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to read a GeoJSON file from S3 into a GeoPandas DataFrame</span></span>
<span id="cb77-41"><a href="#cb77-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read_geojson_from_s3(bucket, key):</span>
<span id="cb77-42"><a href="#cb77-42" aria-hidden="true" tabindex="-1"></a>        geojson_obj <span class="op">=</span> s3.get_object(Bucket<span class="op">=</span>bucket, Key<span class="op">=</span>key)</span>
<span id="cb77-43"><a href="#cb77-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> gpd.read_file(BytesIO(geojson_obj[<span class="st">'Body'</span>].read()))</span>
<span id="cb77-44"><a href="#cb77-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-45"><a href="#cb77-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to read a shapefile from S3 into a GeoPandas DataFrame</span></span>
<span id="cb77-46"><a href="#cb77-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read_shapefile_from_s3(bucket_name, folder_path):</span>
<span id="cb77-47"><a href="#cb77-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a temporary directory to store files</span></span>
<span id="cb77-48"><a href="#cb77-48" aria-hidden="true" tabindex="-1"></a>        local_dir <span class="op">=</span> <span class="st">'/tmp/shp_folder/'</span></span>
<span id="cb77-49"><a href="#cb77-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> os.path.exists(local_dir):</span>
<span id="cb77-50"><a href="#cb77-50" aria-hidden="true" tabindex="-1"></a>            os.makedirs(local_dir)</span>
<span id="cb77-51"><a href="#cb77-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-52"><a href="#cb77-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># List all files in the S3 folder</span></span>
<span id="cb77-53"><a href="#cb77-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb77-54"><a href="#cb77-54" aria-hidden="true" tabindex="-1"></a>            files <span class="op">=</span> s3.list_objects_v2(Bucket<span class="op">=</span>bucket_name, Prefix<span class="op">=</span>folder_path)[<span class="st">'Contents'</span>]</span>
<span id="cb77-55"><a href="#cb77-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> NoCredentialsError:</span>
<span id="cb77-56"><a href="#cb77-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">"Error: No AWS credentials found."</span></span>
<span id="cb77-57"><a href="#cb77-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">KeyError</span>:</span>
<span id="cb77-58"><a href="#cb77-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">"Error: No files found in the specified bucket/folder."</span></span>
<span id="cb77-59"><a href="#cb77-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-60"><a href="#cb77-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Download each file in the folder to the local directory</span></span>
<span id="cb77-61"><a href="#cb77-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> files:</span>
<span id="cb77-62"><a href="#cb77-62" aria-hidden="true" tabindex="-1"></a>            file_name <span class="op">=</span> <span class="bu">file</span>[<span class="st">'Key'</span>].split(<span class="st">'/'</span>)[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb77-63"><a href="#cb77-63" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> file_name.endswith(<span class="st">'.shp'</span>) <span class="kw">or</span> file_name.endswith(<span class="st">'.shx'</span>) <span class="kw">or</span> file_name.endswith(<span class="st">'.dbf'</span>):</span>
<span id="cb77-64"><a href="#cb77-64" aria-hidden="true" tabindex="-1"></a>                s3.download_file(bucket_name, <span class="bu">file</span>[<span class="st">'Key'</span>], local_dir <span class="op">+</span> file_name)</span>
<span id="cb77-65"><a href="#cb77-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-66"><a href="#cb77-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Read the shapefile into a geopandas dataframe</span></span>
<span id="cb77-67"><a href="#cb77-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb77-68"><a href="#cb77-68" aria-hidden="true" tabindex="-1"></a>            shp_files <span class="op">=</span> [os.path.join(local_dir, f) <span class="cf">for</span> f <span class="kw">in</span> os.listdir(local_dir) <span class="cf">if</span> f.endswith(<span class="st">'.shp'</span>)]</span>
<span id="cb77-69"><a href="#cb77-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(shp_files) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb77-70"><a href="#cb77-70" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="st">"Error: No .shp file found in the specified folder."</span></span>
<span id="cb77-71"><a href="#cb77-71" aria-hidden="true" tabindex="-1"></a>            gdf <span class="op">=</span> gpd.read_file(shp_files[<span class="dv">0</span>])</span>
<span id="cb77-72"><a href="#cb77-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-73"><a href="#cb77-73" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if the CRS is set, if not, set it to a default (assuming WGS 84)</span></span>
<span id="cb77-74"><a href="#cb77-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> gdf.crs <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb77-75"><a href="#cb77-75" aria-hidden="true" tabindex="-1"></a>                gdf.set_crs(epsg<span class="op">=</span><span class="dv">4326</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb77-76"><a href="#cb77-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb77-77"><a href="#cb77-77" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Transform CRS to WGS 84 (EPSG:4326) if needed</span></span>
<span id="cb77-78"><a href="#cb77-78" aria-hidden="true" tabindex="-1"></a>                gdf.to_crs(epsg<span class="op">=</span><span class="dv">4326</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb77-79"><a href="#cb77-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> gdf</span>
<span id="cb77-80"><a href="#cb77-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-81"><a href="#cb77-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb77-82"><a href="#cb77-82" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">"Error: "</span> <span class="op">+</span> <span class="bu">str</span>(e)</span>
<span id="cb77-83"><a href="#cb77-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-84"><a href="#cb77-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">finally</span>:</span>
<span id="cb77-85"><a href="#cb77-85" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Clean up the temporary directory</span></span>
<span id="cb77-86"><a href="#cb77-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> f <span class="kw">in</span> os.listdir(local_dir):</span>
<span id="cb77-87"><a href="#cb77-87" aria-hidden="true" tabindex="-1"></a>                os.remove(os.path.join(local_dir, f))</span>
<span id="cb77-88"><a href="#cb77-88" aria-hidden="true" tabindex="-1"></a>            os.rmdir(local_dir)</span>
<span id="cb77-89"><a href="#cb77-89" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb77-90"><a href="#cb77-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to save dataframe into S3</span></span>
<span id="cb77-91"><a href="#cb77-91" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> df_to_s3_csv(df, bucket, key):</span>
<span id="cb77-92"><a href="#cb77-92" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert DataFrame to CSV in-memory</span></span>
<span id="cb77-93"><a href="#cb77-93" aria-hidden="true" tabindex="-1"></a>        csv_buffer <span class="op">=</span> io.StringIO()</span>
<span id="cb77-94"><a href="#cb77-94" aria-hidden="true" tabindex="-1"></a>        df.to_csv(csv_buffer, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb77-95"><a href="#cb77-95" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert String buffer to Bytes buffer</span></span>
<span id="cb77-96"><a href="#cb77-96" aria-hidden="true" tabindex="-1"></a>        csv_buffer_bytes <span class="op">=</span> io.BytesIO(csv_buffer.getvalue().encode())</span>
<span id="cb77-97"><a href="#cb77-97" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Upload to S3</span></span>
<span id="cb77-98"><a href="#cb77-98" aria-hidden="true" tabindex="-1"></a>        s3.put_object(Bucket<span class="op">=</span>bucket, Body<span class="op">=</span>csv_buffer_bytes.getvalue(), Key<span class="op">=</span>key)</span>
<span id="cb77-99"><a href="#cb77-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-100"><a href="#cb77-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-101"><a href="#cb77-101" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Helper functions:</span></span>
<span id="cb77-102"><a href="#cb77-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-103"><a href="#cb77-103" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to access Climate Outlook files from NOAA Climate Prediction Center</span></span>
<span id="cb77-104"><a href="#cb77-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># More information at: https://www.cpc.ncep.noaa.gov/products/predictions/long_range/interactive/index.php</span></span>
<span id="cb77-105"><a href="#cb77-105" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> download_and_extract_seasprcp_files(year, month, s3_bucket, s3_folder):</span>
<span id="cb77-106"><a href="#cb77-106" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if the month is between April and July</span></span>
<span id="cb77-107"><a href="#cb77-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> month <span class="op">&lt;</span> <span class="dv">3</span> <span class="kw">or</span> month <span class="op">&gt;</span> <span class="dv">7</span>:</span>
<span id="cb77-108"><a href="#cb77-108" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb77-109"><a href="#cb77-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-110"><a href="#cb77-110" aria-hidden="true" tabindex="-1"></a>        base_url <span class="op">=</span> <span class="st">'https://ftp.cpc.ncep.noaa.gov/GIS/us_tempprcpfcst/'</span></span>
<span id="cb77-111"><a href="#cb77-111" aria-hidden="true" tabindex="-1"></a>        filename <span class="op">=</span> <span class="st">'seasprcp_</span><span class="sc">{0:04d}{1:02d}</span><span class="st">.zip'</span>.<span class="bu">format</span>(year, month)</span>
<span id="cb77-112"><a href="#cb77-112" aria-hidden="true" tabindex="-1"></a>        url <span class="op">=</span> base_url <span class="op">+</span> filename</span>
<span id="cb77-113"><a href="#cb77-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-114"><a href="#cb77-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb77-115"><a href="#cb77-115" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check and delete existing files in the S3 folder</span></span>
<span id="cb77-116"><a href="#cb77-116" aria-hidden="true" tabindex="-1"></a>            response <span class="op">=</span> s3.list_objects_v2(Bucket<span class="op">=</span>s3_bucket, Prefix<span class="op">=</span>s3_folder)</span>
<span id="cb77-117"><a href="#cb77-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="st">'Contents'</span> <span class="kw">in</span> response:</span>
<span id="cb77-118"><a href="#cb77-118" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> obj <span class="kw">in</span> response[<span class="st">'Contents'</span>]:</span>
<span id="cb77-119"><a href="#cb77-119" aria-hidden="true" tabindex="-1"></a>                    s3.delete_object(Bucket<span class="op">=</span>s3_bucket, Key<span class="op">=</span>obj[<span class="st">'Key'</span>])</span>
<span id="cb77-120"><a href="#cb77-120" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Download the ZIP file</span></span>
<span id="cb77-121"><a href="#cb77-121" aria-hidden="true" tabindex="-1"></a>            response <span class="op">=</span> requests.get(url)</span>
<span id="cb77-122"><a href="#cb77-122" aria-hidden="true" tabindex="-1"></a>            response.raise_for_status()</span>
<span id="cb77-123"><a href="#cb77-123" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create a temporary file for the ZIP</span></span>
<span id="cb77-124"><a href="#cb77-124" aria-hidden="true" tabindex="-1"></a>            temp_zip_path <span class="op">=</span> <span class="st">'/tmp/'</span> <span class="op">+</span> filename</span>
<span id="cb77-125"><a href="#cb77-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">with</span> <span class="bu">open</span>(temp_zip_path, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb77-126"><a href="#cb77-126" aria-hidden="true" tabindex="-1"></a>                f.write(response.content)</span>
<span id="cb77-127"><a href="#cb77-127" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Extract files and upload to S3</span></span>
<span id="cb77-128"><a href="#cb77-128" aria-hidden="true" tabindex="-1"></a>            <span class="cf">with</span> zipfile.ZipFile(temp_zip_path, <span class="st">'r'</span>) <span class="im">as</span> zip_ref:</span>
<span id="cb77-129"><a href="#cb77-129" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> zip_ref.namelist():</span>
<span id="cb77-130"><a href="#cb77-130" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="bu">file</span>.startswith(<span class="st">'lead1_'</span>):</span>
<span id="cb77-131"><a href="#cb77-131" aria-hidden="true" tabindex="-1"></a>                        zip_ref.extract(<span class="bu">file</span>, <span class="st">'/tmp/'</span>)</span>
<span id="cb77-132"><a href="#cb77-132" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Splitting the file name and extension</span></span>
<span id="cb77-133"><a href="#cb77-133" aria-hidden="true" tabindex="-1"></a>                        file_name, file_extension <span class="op">=</span> os.path.splitext(<span class="bu">file</span>)</span>
<span id="cb77-134"><a href="#cb77-134" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Renaming file with _prcp and year, preserving the original extension</span></span>
<span id="cb77-135"><a href="#cb77-135" aria-hidden="true" tabindex="-1"></a>                        new_filename <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>file_name<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>year<span class="sc">}{</span>file_extension<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb77-136"><a href="#cb77-136" aria-hidden="true" tabindex="-1"></a>                        os.rename(<span class="st">'/tmp/'</span> <span class="op">+</span> <span class="bu">file</span>, <span class="st">'/tmp/'</span> <span class="op">+</span> new_filename)</span>
<span id="cb77-137"><a href="#cb77-137" aria-hidden="true" tabindex="-1"></a>                        s3.upload_file(<span class="st">'/tmp/'</span> <span class="op">+</span> new_filename, s3_bucket, s3_folder <span class="op">+</span> <span class="st">'/'</span> <span class="op">+</span> new_filename)</span>
<span id="cb77-138"><a href="#cb77-138" aria-hidden="true" tabindex="-1"></a>                        os.remove(<span class="st">'/tmp/'</span> <span class="op">+</span> new_filename)</span>
<span id="cb77-139"><a href="#cb77-139" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Remove the ZIP file after extraction</span></span>
<span id="cb77-140"><a href="#cb77-140" aria-hidden="true" tabindex="-1"></a>            os.remove(temp_zip_path)</span>
<span id="cb77-141"><a href="#cb77-141" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">"Files starting with 'lead1' extracted and uploaded to S3 successfully."</span></span>
<span id="cb77-142"><a href="#cb77-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-143"><a href="#cb77-143" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> requests.exceptions.HTTPError <span class="im">as</span> err:</span>
<span id="cb77-144"><a href="#cb77-144" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">"HTTP Error: "</span> <span class="op">+</span> <span class="bu">str</span>(err)</span>
<span id="cb77-145"><a href="#cb77-145" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> zipfile.BadZipFile:</span>
<span id="cb77-146"><a href="#cb77-146" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">"Error: The downloaded file is not a zip file."</span></span>
<span id="cb77-147"><a href="#cb77-147" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb77-148"><a href="#cb77-148" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">"Error: "</span> <span class="op">+</span> <span class="bu">str</span>(e)</span>
<span id="cb77-149"><a href="#cb77-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-150"><a href="#cb77-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-151"><a href="#cb77-151" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to associate each grid cell to the climate outlook</span></span>
<span id="cb77-152"><a href="#cb77-152" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> join_attributes_by_largest_overlap(seasprcp_raw, precip_grid_raw):</span>
<span id="cb77-153"><a href="#cb77-153" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb77-154"><a href="#cb77-154" aria-hidden="true" tabindex="-1"></a>        seasprcp_projected <span class="op">=</span> seasprcp_raw.to_crs(epsg<span class="op">=</span><span class="dv">4326</span>)</span>
<span id="cb77-155"><a href="#cb77-155" aria-hidden="true" tabindex="-1"></a>        precip_grid_projected <span class="op">=</span> precip_grid_raw.to_crs(epsg<span class="op">=</span><span class="dv">4326</span>)</span>
<span id="cb77-156"><a href="#cb77-156" aria-hidden="true" tabindex="-1"></a>        intersection <span class="op">=</span> gpd.overlay(seasprcp_projected, precip_grid_projected, how<span class="op">=</span><span class="st">'intersection'</span>)</span>
<span id="cb77-157"><a href="#cb77-157" aria-hidden="true" tabindex="-1"></a>        intersection[<span class="st">'area'</span>] <span class="op">=</span> intersection.geometry.area</span>
<span id="cb77-158"><a href="#cb77-158" aria-hidden="true" tabindex="-1"></a>        intersection.sort_values(by<span class="op">=</span><span class="st">'area'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb77-159"><a href="#cb77-159" aria-hidden="true" tabindex="-1"></a>        intersection.drop_duplicates(subset<span class="op">=</span><span class="st">'gridid'</span>, keep<span class="op">=</span><span class="st">'last'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb77-160"><a href="#cb77-160" aria-hidden="true" tabindex="-1"></a>        intersection <span class="op">=</span> intersection.to_crs(epsg<span class="op">=</span><span class="dv">4326</span>)</span>
<span id="cb77-161"><a href="#cb77-161" aria-hidden="true" tabindex="-1"></a>        joined <span class="op">=</span> seasprcp_raw.merge(intersection[[<span class="st">'gridid'</span>,<span class="st">'Cat'</span>,<span class="st">'Prob'</span>]], left_on<span class="op">=</span><span class="st">'gridid'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>).clean_names()</span>
<span id="cb77-162"><a href="#cb77-162" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb77-163"><a href="#cb77-163" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> joined</span>
<span id="cb77-164"><a href="#cb77-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-165"><a href="#cb77-165" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Process and store updated Spatial Data ------------------#</span></span>
<span id="cb77-166"><a href="#cb77-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-167"><a href="#cb77-167" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Downloading spatial data from NOAA CPC..."</span>)</span>
<span id="cb77-168"><a href="#cb77-168" aria-hidden="true" tabindex="-1"></a>    download_result <span class="op">=</span> download_and_extract_seasprcp_files(datetime.now().year, datetime.now().month, bucket_name, key_path_seasprcp_data_read)</span>
<span id="cb77-169"><a href="#cb77-169" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> download_result <span class="kw">is</span> <span class="va">False</span>:</span>
<span id="cb77-170"><a href="#cb77-170" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"     No download required. Month is not between April and July."</span>)</span>
<span id="cb77-171"><a href="#cb77-171" aria-hidden="true" tabindex="-1"></a>        sys.exit() </span>
<span id="cb77-172"><a href="#cb77-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-173"><a href="#cb77-173" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Preparing spatial data..."</span>)</span>
<span id="cb77-174"><a href="#cb77-174" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reference forecast to climate outlooks</span></span>
<span id="cb77-175"><a href="#cb77-175" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"     Read climate data from S3..."</span>)</span>
<span id="cb77-176"><a href="#cb77-176" aria-hidden="true" tabindex="-1"></a>    seasprcp_raw <span class="op">=</span> read_shapefile_from_s3(bucket_name, key_path_seasprcp_data_read)</span>
<span id="cb77-177"><a href="#cb77-177" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(seasprcp_raw, <span class="bu">str</span>):</span>
<span id="cb77-178"><a href="#cb77-178" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"         "</span>,seasprcp_raw)</span>
<span id="cb77-179"><a href="#cb77-179" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb77-180"><a href="#cb77-180" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"         Climate data read successfully."</span>)</span>
<span id="cb77-181"><a href="#cb77-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-182"><a href="#cb77-182" aria-hidden="true" tabindex="-1"></a>    seasprcp_raw[<span class="st">'Prob'</span>] <span class="op">=</span> seasprcp_raw[<span class="st">'Prob'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)<span class="op">*</span><span class="dv">100</span> <span class="cf">if</span> x <span class="op">==</span> <span class="fl">33.0</span> <span class="cf">else</span> x)</span>
<span id="cb77-183"><a href="#cb77-183" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Read in AOI Grid</span></span>
<span id="cb77-184"><a href="#cb77-184" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"     Read in AOI grid..."</span>)</span>
<span id="cb77-185"><a href="#cb77-185" aria-hidden="true" tabindex="-1"></a>    grasscast_aoi_grid <span class="op">=</span> read_geojson_from_s3(bucket_name, key_path_grasscast_grid_read)</span>
<span id="cb77-186"><a href="#cb77-186" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply function to associate each grid cell to the climate outlook</span></span>
<span id="cb77-187"><a href="#cb77-187" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"     Join climate attributes to grid..."</span>)</span>
<span id="cb77-188"><a href="#cb77-188" aria-hidden="true" tabindex="-1"></a>    seasprcp_grid <span class="op">=</span> join_attributes_by_largest_overlap(grasscast_aoi_grid, seasprcp_raw)</span>
<span id="cb77-189"><a href="#cb77-189" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save data</span></span>
<span id="cb77-190"><a href="#cb77-190" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Save spatial data outputs to S3..."</span>)</span>
<span id="cb77-191"><a href="#cb77-191" aria-hidden="true" tabindex="-1"></a>    df_to_s3_csv(seasprcp_grid, bucket_name, key_path_seasprcp_grid_read)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="forecast-lambda-function" class="level4">
<h4 class="anchored" data-anchor-id="forecast-lambda-function">Forecast Lambda Function</h4>
<p>As for the climate function, the lambda function responsible for updating GrassCast values shares much of the processing code implemented for generating the original datasets described in the Data section. This section provides the code required to web scrape data from GrassCast, retrieve the latest forecast values, correlate them with climate outlooks, and determine the expected forecast scenario. Additionally, the updated forecast dataset, ready for display, is used to update the historical series dataset by incorporating the most recent forecasted value and combining information from both regions (SW and GP) into a single dataset.</p>
<p>You can find the fully functional lambda function with its respective handler in the “aws-lambda” folder within the GitHub repository, ready to be executed.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lambda_function():</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Importing Libraries ------------------ #</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> sys</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> datetime <span class="im">import</span> date, datetime, timedelta</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> requests</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> janitor</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> json</span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> io</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> io <span class="im">import</span> BytesIO</span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> boto3 </span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ AWS S3 parameters ------------------ #</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>    s3 <span class="op">=</span> boto3.client(<span class="st">'s3'</span>)  <span class="co"># Initializing Amazon S3 client</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>    bucket_name <span class="op">=</span> <span class="st">'foodsight-lambda'</span>  <span class="co"># Name of the S3 bucket</span></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>    key_path_all_hist_read <span class="op">=</span> <span class="st">'hist_data/hist_data_grasscast_gp_sw.csv'</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a>    key_path_gp_hist_read <span class="op">=</span> <span class="st">'hist_data/updated_hist_data_grasscast_gp.csv'</span></span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a>    key_path_sw_hist_read <span class="op">=</span> <span class="st">'hist_data/updated_hist_data_grasscast_sw.csv'</span></span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a>    key_path_all_forecast_read <span class="op">=</span> <span class="st">'forecast_data/forecast_data_grasscast_gp_sw.csv'</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a>    key_path_gp_forecast_read <span class="op">=</span> <span class="st">'forecast_data/forecast_data_grasscast_gp_clim.csv'</span></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a>    key_path_sw_forecast_read <span class="op">=</span> <span class="st">'forecast_data/forecast_data_grasscast_sw_clim.csv'</span></span>
<span id="cb78-27"><a href="#cb78-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-28"><a href="#cb78-28" aria-hidden="true" tabindex="-1"></a>    key_path_seasprcp_grid_read <span class="op">=</span> <span class="st">'spatial_data/seasprcp_grid.csv'</span></span>
<span id="cb78-29"><a href="#cb78-29" aria-hidden="true" tabindex="-1"></a>    key_path_overlapping_gridids_read <span class="op">=</span> <span class="st">'spatial_data/overlapping_gridids.json'</span></span>
<span id="cb78-30"><a href="#cb78-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-31"><a href="#cb78-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-32"><a href="#cb78-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># S3 loading functions</span></span>
<span id="cb78-33"><a href="#cb78-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read_csv_from_s3(bucket, key):</span>
<span id="cb78-34"><a href="#cb78-34" aria-hidden="true" tabindex="-1"></a>        csv_obj <span class="op">=</span> s3.get_object(Bucket<span class="op">=</span>bucket, Key<span class="op">=</span>key)</span>
<span id="cb78-35"><a href="#cb78-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pd.read_csv(BytesIO(csv_obj[<span class="st">'Body'</span>].read()))</span>
<span id="cb78-36"><a href="#cb78-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-37"><a href="#cb78-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to read a JSON file from S3</span></span>
<span id="cb78-38"><a href="#cb78-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read_json_from_s3(bucket, key):</span>
<span id="cb78-39"><a href="#cb78-39" aria-hidden="true" tabindex="-1"></a>        response <span class="op">=</span> s3.get_object(Bucket<span class="op">=</span>bucket, Key<span class="op">=</span>key)</span>
<span id="cb78-40"><a href="#cb78-40" aria-hidden="true" tabindex="-1"></a>        json_obj <span class="op">=</span> response[<span class="st">'Body'</span>].read().decode(<span class="st">'utf-8'</span>)</span>
<span id="cb78-41"><a href="#cb78-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pd.DataFrame(json.loads(json_obj))</span>
<span id="cb78-42"><a href="#cb78-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-43"><a href="#cb78-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># S3 saving function</span></span>
<span id="cb78-44"><a href="#cb78-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> df_to_s3_csv(df, bucket, key):</span>
<span id="cb78-45"><a href="#cb78-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert DataFrame to CSV in-memory</span></span>
<span id="cb78-46"><a href="#cb78-46" aria-hidden="true" tabindex="-1"></a>        csv_buffer <span class="op">=</span> io.StringIO()</span>
<span id="cb78-47"><a href="#cb78-47" aria-hidden="true" tabindex="-1"></a>        df.to_csv(csv_buffer, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb78-48"><a href="#cb78-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert String buffer to Bytes buffer</span></span>
<span id="cb78-49"><a href="#cb78-49" aria-hidden="true" tabindex="-1"></a>        csv_buffer_bytes <span class="op">=</span> io.BytesIO(csv_buffer.getvalue().encode())</span>
<span id="cb78-50"><a href="#cb78-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Upload to S3</span></span>
<span id="cb78-51"><a href="#cb78-51" aria-hidden="true" tabindex="-1"></a>        s3.put_object(Bucket<span class="op">=</span>bucket, Body<span class="op">=</span>csv_buffer_bytes.getvalue(), Key<span class="op">=</span>key)</span>
<span id="cb78-52"><a href="#cb78-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-53"><a href="#cb78-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-54"><a href="#cb78-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Define functions ------------------#</span></span>
<span id="cb78-55"><a href="#cb78-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Predefined functions:</span></span>
<span id="cb78-56"><a href="#cb78-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-57"><a href="#cb78-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to pull the latest forecast data from the Grass-Cast website</span></span>
<span id="cb78-58"><a href="#cb78-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> download_forecast_lambda(year<span class="op">=</span>date.today().year, region_code<span class="op">=</span><span class="st">'gp'</span>, existing_df<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb78-59"><a href="#cb78-59" aria-hidden="true" tabindex="-1"></a>        base_url <span class="op">=</span> <span class="st">"https://grasscast.unl.edu/data/csv/</span><span class="sc">{year}</span><span class="st">/ANPP_forecast_summary_</span><span class="sc">{region_code}</span><span class="st">_</span><span class="sc">{year}</span><span class="st">_</span><span class="sc">{month}</span><span class="st">_</span><span class="sc">{day}</span><span class="st">.csv"</span></span>
<span id="cb78-60"><a href="#cb78-60" aria-hidden="true" tabindex="-1"></a>        month_names <span class="op">=</span> {<span class="dv">4</span>: <span class="st">"April"</span>, <span class="dv">5</span>: <span class="st">"May"</span>, <span class="dv">6</span>: <span class="st">"June"</span>, <span class="dv">7</span>: <span class="st">"July"</span>, <span class="dv">8</span>: <span class="st">"August"</span>, <span class="dv">9</span>: <span class="st">"September"</span>}</span>
<span id="cb78-61"><a href="#cb78-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-62"><a href="#cb78-62" aria-hidden="true" tabindex="-1"></a>        <span class="co"># List of shared columns</span></span>
<span id="cb78-63"><a href="#cb78-63" aria-hidden="true" tabindex="-1"></a>        shared_columns <span class="op">=</span> [<span class="st">'fips'</span>, <span class="st">'countystate'</span>, <span class="st">'gridid'</span>, <span class="st">'indx'</span>, <span class="st">'year'</span>, <span class="st">'meanndvigrid'</span>, <span class="st">'meananppgrid'</span>, </span>
<span id="cb78-64"><a href="#cb78-64" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'ndvi_predict_below'</span>, <span class="st">'npp_predict_below'</span>, <span class="st">'npp_stdev_below'</span>, <span class="st">'deltanpp_below'</span>, </span>
<span id="cb78-65"><a href="#cb78-65" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'pct_diffnpp_below'</span>, <span class="st">'ndvi_predict_avg'</span>, <span class="st">'npp_predict_avg'</span>, <span class="st">'npp_stdev_avg'</span>, </span>
<span id="cb78-66"><a href="#cb78-66" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'deltanpp_avg'</span>, <span class="st">'pct_diffnpp_avg'</span>, <span class="st">'ndvi_predict_above'</span>, <span class="st">'npp_predict_above'</span>, </span>
<span id="cb78-67"><a href="#cb78-67" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'npp_stdev_above'</span>, <span class="st">'deltanpp_above'</span>, <span class="st">'pct_diffnpp_above'</span>, <span class="st">'report_date'</span>]</span>
<span id="cb78-68"><a href="#cb78-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-69"><a href="#cb78-69" aria-hidden="true" tabindex="-1"></a>        start_date <span class="op">=</span> datetime(year, <span class="dv">4</span>, <span class="dv">1</span>)  <span class="co"># Default start date is April 1st of the given year</span></span>
<span id="cb78-70"><a href="#cb78-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-71"><a href="#cb78-71" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If an existing dataframe is provided, find the next date after the latest report_date</span></span>
<span id="cb78-72"><a href="#cb78-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> existing_df <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> <span class="kw">not</span> existing_df.empty:</span>
<span id="cb78-73"><a href="#cb78-73" aria-hidden="true" tabindex="-1"></a>            most_recent_report_date <span class="op">=</span> pd.to_datetime(existing_df[<span class="st">'report_date'</span>].<span class="bu">max</span>()).year</span>
<span id="cb78-74"><a href="#cb78-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-75"><a href="#cb78-75" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> most_recent_report_date <span class="op">!=</span> year :</span>
<span id="cb78-76"><a href="#cb78-76" aria-hidden="true" tabindex="-1"></a>                existing_df <span class="op">=</span> <span class="va">None</span></span>
<span id="cb78-77"><a href="#cb78-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb78-78"><a href="#cb78-78" aria-hidden="true" tabindex="-1"></a>                existing_df[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(existing_df[<span class="st">'report_date'</span>]).astype(<span class="st">'datetime64[us]'</span>)</span>
<span id="cb78-79"><a href="#cb78-79" aria-hidden="true" tabindex="-1"></a>                last_date <span class="op">=</span> existing_df[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb78-80"><a href="#cb78-80" aria-hidden="true" tabindex="-1"></a>                start_date <span class="op">=</span> last_date <span class="op">+</span> timedelta(days<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb78-81"><a href="#cb78-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-82"><a href="#cb78-82" aria-hidden="true" tabindex="-1"></a>        new_data_downloaded <span class="op">=</span> <span class="va">False</span>  <span class="co"># Flag to track if data is downloaded</span></span>
<span id="cb78-83"><a href="#cb78-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-84"><a href="#cb78-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> month <span class="kw">in</span> <span class="bu">range</span>(start_date.month, <span class="dv">10</span>):  <span class="co"># From starting month to September</span></span>
<span id="cb78-85"><a href="#cb78-85" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Setting the end day of the month</span></span>
<span id="cb78-86"><a href="#cb78-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> month <span class="kw">in</span> [<span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">9</span>]:  <span class="co"># April, June, September have 30 days</span></span>
<span id="cb78-87"><a href="#cb78-87" aria-hidden="true" tabindex="-1"></a>                end_day <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb78-88"><a href="#cb78-88" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb78-89"><a href="#cb78-89" aria-hidden="true" tabindex="-1"></a>                end_day <span class="op">=</span> <span class="dv">31</span></span>
<span id="cb78-90"><a href="#cb78-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-91"><a href="#cb78-91" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> day <span class="kw">in</span> <span class="bu">range</span>(start_date.day <span class="cf">if</span> month <span class="op">==</span> start_date.month <span class="cf">else</span> <span class="dv">1</span>, end_day <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb78-92"><a href="#cb78-92" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Constructing the URL for each specific date</span></span>
<span id="cb78-93"><a href="#cb78-93" aria-hidden="true" tabindex="-1"></a>                url <span class="op">=</span> base_url.<span class="bu">format</span>(year<span class="op">=</span>year, region_code<span class="op">=</span>region_code, month<span class="op">=</span>month_names[month], day<span class="op">=</span>day)</span>
<span id="cb78-94"><a href="#cb78-94" aria-hidden="true" tabindex="-1"></a>                <span class="cf">try</span>:</span>
<span id="cb78-95"><a href="#cb78-95" aria-hidden="true" tabindex="-1"></a>                    response <span class="op">=</span> requests.get(url)</span>
<span id="cb78-96"><a href="#cb78-96" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> response.status_code <span class="op">==</span> <span class="dv">200</span>:</span>
<span id="cb78-97"><a href="#cb78-97" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">print</span>(<span class="ss">f"Data found and downloaded for date: </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>day<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb78-98"><a href="#cb78-98" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">print</span>(url)</span>
<span id="cb78-99"><a href="#cb78-99" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Reading the CSV into a Pandas dataframe</span></span>
<span id="cb78-100"><a href="#cb78-100" aria-hidden="true" tabindex="-1"></a>                        new_df <span class="op">=</span> pd.read_csv(url)</span>
<span id="cb78-101"><a href="#cb78-101" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Create report_date variable in date format</span></span>
<span id="cb78-102"><a href="#cb78-102" aria-hidden="true" tabindex="-1"></a>                        report_date <span class="op">=</span> datetime(year, month, day)</span>
<span id="cb78-103"><a href="#cb78-103" aria-hidden="true" tabindex="-1"></a>                        new_df[<span class="st">'report_date'</span>] <span class="op">=</span> report_date</span>
<span id="cb78-104"><a href="#cb78-104" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Rename the columns to lowercase and replace spaces with underscores</span></span>
<span id="cb78-105"><a href="#cb78-105" aria-hidden="true" tabindex="-1"></a>                        new_df <span class="op">=</span> new_df.clean_names()</span>
<span id="cb78-106"><a href="#cb78-106" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Filter the dataframe to include only the shared columns</span></span>
<span id="cb78-107"><a href="#cb78-107" aria-hidden="true" tabindex="-1"></a>                        new_df <span class="op">=</span> new_df[shared_columns]</span>
<span id="cb78-108"><a href="#cb78-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-109"><a href="#cb78-109" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Concatenate with the existing dataframe</span></span>
<span id="cb78-110"><a href="#cb78-110" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> existing_df <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb78-111"><a href="#cb78-111" aria-hidden="true" tabindex="-1"></a>                            existing_df <span class="op">=</span> pd.concat([existing_df, new_df], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb78-112"><a href="#cb78-112" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">else</span>:</span>
<span id="cb78-113"><a href="#cb78-113" aria-hidden="true" tabindex="-1"></a>                            existing_df <span class="op">=</span> new_df</span>
<span id="cb78-114"><a href="#cb78-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-115"><a href="#cb78-115" aria-hidden="true" tabindex="-1"></a>                        new_data_downloaded <span class="op">=</span> <span class="va">True</span></span>
<span id="cb78-116"><a href="#cb78-116" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> existing_df</span>
<span id="cb78-117"><a href="#cb78-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-118"><a href="#cb78-118" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb78-119"><a href="#cb78-119" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">print</span>(<span class="ss">f"No data available for date: </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>day<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb78-120"><a href="#cb78-120" aria-hidden="true" tabindex="-1"></a>                <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb78-121"><a href="#cb78-121" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Error downloading file for date: </span><span class="sc">{</span>year<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>month<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>day<span class="sc">}</span><span class="ss">, Error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb78-122"><a href="#cb78-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-123"><a href="#cb78-123" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> new_data_downloaded <span class="kw">is</span> <span class="va">False</span>:</span>
<span id="cb78-124"><a href="#cb78-124" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"No new data downloaded for </span><span class="sc">{</span>region_code<span class="sc">}</span><span class="ss"> region. Stopping execution."</span>)</span>
<span id="cb78-125"><a href="#cb78-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb78-126"><a href="#cb78-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-127"><a href="#cb78-127" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb78-128"><a href="#cb78-128" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to calculate ANPP based on climate outlook </span></span>
<span id="cb78-129"><a href="#cb78-129" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculate_NPP_predict_clim(row):</span>
<span id="cb78-130"><a href="#cb78-130" aria-hidden="true" tabindex="-1"></a>        Cat <span class="op">=</span> row[<span class="st">'cat'</span>]</span>
<span id="cb78-131"><a href="#cb78-131" aria-hidden="true" tabindex="-1"></a>        Prob <span class="op">=</span> row[<span class="st">'prob'</span>]</span>
<span id="cb78-132"><a href="#cb78-132" aria-hidden="true" tabindex="-1"></a>        NPP_predict_below <span class="op">=</span> row[<span class="st">'npp_predict_below'</span>]</span>
<span id="cb78-133"><a href="#cb78-133" aria-hidden="true" tabindex="-1"></a>        NPP_predict_above <span class="op">=</span> row[<span class="st">'npp_predict_above'</span>]</span>
<span id="cb78-134"><a href="#cb78-134" aria-hidden="true" tabindex="-1"></a>        NPP_predict_avg <span class="op">=</span> row[<span class="st">'npp_predict_avg'</span>]</span>
<span id="cb78-135"><a href="#cb78-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-136"><a href="#cb78-136" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Cat <span class="op">==</span> <span class="st">'EC'</span>:</span>
<span id="cb78-137"><a href="#cb78-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> NPP_predict_below <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_avg <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_above <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)</span>
<span id="cb78-138"><a href="#cb78-138" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb78-139"><a href="#cb78-139" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate remaining_prob</span></span>
<span id="cb78-140"><a href="#cb78-140" aria-hidden="true" tabindex="-1"></a>            remaining_prob <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> ((Prob <span class="op">/</span> <span class="dv">100</span>) <span class="op">+</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>))</span>
<span id="cb78-141"><a href="#cb78-141" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> Cat <span class="op">==</span> <span class="st">'Below'</span>:</span>
<span id="cb78-142"><a href="#cb78-142" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (NPP_predict_below <span class="op">*</span> (Prob <span class="op">/</span> <span class="dv">100</span>)) <span class="op">+</span> NPP_predict_avg <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_above <span class="op">*</span> remaining_prob</span>
<span id="cb78-143"><a href="#cb78-143" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> Cat <span class="op">==</span> <span class="st">'Above'</span>:</span>
<span id="cb78-144"><a href="#cb78-144" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (NPP_predict_above <span class="op">*</span> (Prob <span class="op">/</span> <span class="dv">100</span>)) <span class="op">+</span> NPP_predict_avg <span class="op">*</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span> NPP_predict_below <span class="op">*</span> remaining_prob</span>
<span id="cb78-145"><a href="#cb78-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-146"><a href="#cb78-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-147"><a href="#cb78-147" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Prepare Spatial Data ------------------#</span></span>
<span id="cb78-148"><a href="#cb78-148" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Reading spatial data..."</span>)</span>
<span id="cb78-149"><a href="#cb78-149" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Read spatial data</span></span>
<span id="cb78-150"><a href="#cb78-150" aria-hidden="true" tabindex="-1"></a>    seasprcp_grid <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_seasprcp_grid_read)</span>
<span id="cb78-151"><a href="#cb78-151" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb78-152"><a href="#cb78-152" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Pull new forecast data from GrassCast ------------------#</span></span>
<span id="cb78-153"><a href="#cb78-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-154"><a href="#cb78-154" aria-hidden="true" tabindex="-1"></a>    <span class="co"># SW data</span></span>
<span id="cb78-155"><a href="#cb78-155" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Pulling SW data from GrassCast..."</span>)</span>
<span id="cb78-156"><a href="#cb78-156" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Download the latest forecast data for the SW region</span></span>
<span id="cb78-157"><a href="#cb78-157" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Load the previous forecast records (if any) to concatenate and set the start date </span></span>
<span id="cb78-158"><a href="#cb78-158" aria-hidden="true" tabindex="-1"></a>    existing_df <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_sw_forecast_read)</span>
<span id="cb78-159"><a href="#cb78-159" aria-hidden="true" tabindex="-1"></a>    columns_to_exclude <span class="op">=</span> [<span class="st">'cat'</span>, <span class="st">'prob'</span>, <span class="st">'npp_predict_clim'</span>]</span>
<span id="cb78-160"><a href="#cb78-160" aria-hidden="true" tabindex="-1"></a>    existing_df <span class="op">=</span> existing_df[[col <span class="cf">for</span> col <span class="kw">in</span> existing_df.columns <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> columns_to_exclude]]</span>
<span id="cb78-161"><a href="#cb78-161" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply function</span></span>
<span id="cb78-162"><a href="#cb78-162" aria-hidden="true" tabindex="-1"></a>    grasscast_forecast_sw  <span class="op">=</span> download_forecast_lambda(year<span class="op">=</span>date.today().year, region_code<span class="op">=</span><span class="st">'sw'</span>, existing_df<span class="op">=</span>existing_df)</span>
<span id="cb78-163"><a href="#cb78-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-164"><a href="#cb78-164" aria-hidden="true" tabindex="-1"></a>    <span class="co"># GP data</span></span>
<span id="cb78-165"><a href="#cb78-165" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Pulling GP data from GrassCast..."</span>)</span>
<span id="cb78-166"><a href="#cb78-166" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Download the latest forecast data for the GP region</span></span>
<span id="cb78-167"><a href="#cb78-167" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Load the previous forecast records (if any) to concatenate and set the start date</span></span>
<span id="cb78-168"><a href="#cb78-168" aria-hidden="true" tabindex="-1"></a>    existing_df <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_gp_forecast_read)</span>
<span id="cb78-169"><a href="#cb78-169" aria-hidden="true" tabindex="-1"></a>    columns_to_exclude <span class="op">=</span> [<span class="st">'cat'</span>, <span class="st">'prob'</span>, <span class="st">'npp_predict_clim'</span>]</span>
<span id="cb78-170"><a href="#cb78-170" aria-hidden="true" tabindex="-1"></a>    existing_df <span class="op">=</span> existing_df[[col <span class="cf">for</span> col <span class="kw">in</span> existing_df.columns <span class="cf">if</span> col <span class="kw">not</span> <span class="kw">in</span> columns_to_exclude]]</span>
<span id="cb78-171"><a href="#cb78-171" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply function</span></span>
<span id="cb78-172"><a href="#cb78-172" aria-hidden="true" tabindex="-1"></a>    grasscast_forecast_gp <span class="op">=</span> download_forecast_lambda(year<span class="op">=</span>date.today().year, region_code<span class="op">=</span><span class="st">'gp'</span>, existing_df<span class="op">=</span>existing_df)</span>
<span id="cb78-173"><a href="#cb78-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-174"><a href="#cb78-174" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Stop execution if no new data was downloaded</span></span>
<span id="cb78-175"><a href="#cb78-175" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> grasscast_forecast_sw <span class="kw">is</span> <span class="va">None</span> <span class="kw">and</span> grasscast_forecast_gp <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb78-176"><a href="#cb78-176" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No new data available. Stopping execution."</span>)</span>
<span id="cb78-177"><a href="#cb78-177" aria-hidden="true" tabindex="-1"></a>        sys.exit()</span>
<span id="cb78-178"><a href="#cb78-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-179"><a href="#cb78-179" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Apply updates for SW ------------------#</span></span>
<span id="cb78-180"><a href="#cb78-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-181"><a href="#cb78-181" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> grasscast_forecast_sw <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb78-182"><a href="#cb78-182" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Updating SW data..."</span>)</span>
<span id="cb78-183"><a href="#cb78-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-184"><a href="#cb78-184" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add new climate related variables to the forecast dataset</span></span>
<span id="cb78-185"><a href="#cb78-185" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Merge forecast data with grid based on Id</span></span>
<span id="cb78-186"><a href="#cb78-186" aria-hidden="true" tabindex="-1"></a>        grasscast_forecast_sw_clim <span class="op">=</span> pd.merge(grasscast_forecast_sw, </span>
<span id="cb78-187"><a href="#cb78-187" aria-hidden="true" tabindex="-1"></a>                                            seasprcp_grid[[<span class="st">'gridid'</span>, <span class="st">'cat'</span>, <span class="st">'prob'</span>]], </span>
<span id="cb78-188"><a href="#cb78-188" aria-hidden="true" tabindex="-1"></a>                                            left_on<span class="op">=</span><span class="st">'gridid'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb78-189"><a href="#cb78-189" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply function to calculate ANPP based on climate outlook to SW DataFrame</span></span>
<span id="cb78-190"><a href="#cb78-190" aria-hidden="true" tabindex="-1"></a>        grasscast_forecast_sw_clim[<span class="st">'npp_predict_clim'</span>] <span class="op">=</span> grasscast_forecast_sw_clim.<span class="bu">apply</span>(calculate_NPP_predict_clim, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb78-191"><a href="#cb78-191" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store the updated forecast dataset to be used in the following iteration to pull updated data from GrassCast</span></span>
<span id="cb78-192"><a href="#cb78-192" aria-hidden="true" tabindex="-1"></a>        df_to_s3_csv(grasscast_forecast_sw_clim, bucket_name, key_path_sw_forecast_read)</span>
<span id="cb78-193"><a href="#cb78-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-194"><a href="#cb78-194" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update last record on the historical dataset based on new forecast data</span></span>
<span id="cb78-195"><a href="#cb78-195" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Load last available historical data</span></span>
<span id="cb78-196"><a href="#cb78-196" aria-hidden="true" tabindex="-1"></a>        hist_sw <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_sw_hist_read)</span>
<span id="cb78-197"><a href="#cb78-197" aria-hidden="true" tabindex="-1"></a>        forecast_sw <span class="op">=</span> grasscast_forecast_sw_clim</span>
<span id="cb78-198"><a href="#cb78-198" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Assuming grasscast_forecast_sw_clim is already loaded as forecast_sw</span></span>
<span id="cb78-199"><a href="#cb78-199" aria-hidden="true" tabindex="-1"></a>        forecast_sw[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(forecast_sw[<span class="st">'report_date'</span>])</span>
<span id="cb78-200"><a href="#cb78-200" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Filter for the last day of May and the last day of the year</span></span>
<span id="cb78-201"><a href="#cb78-201" aria-hidden="true" tabindex="-1"></a>        last_day_may <span class="op">=</span> forecast_sw[forecast_sw[<span class="st">'report_date'</span>].dt.month <span class="op">==</span> <span class="dv">5</span>].groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb78-202"><a href="#cb78-202" aria-hidden="true" tabindex="-1"></a>        last_day_year <span class="op">=</span> forecast_sw.groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb78-203"><a href="#cb78-203" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Group by 'year' and get the last 'report_date'</span></span>
<span id="cb78-204"><a href="#cb78-204" aria-hidden="true" tabindex="-1"></a>        max_dates_per_year <span class="op">=</span> pd.concat([last_day_may, last_day_year])</span>
<span id="cb78-205"><a href="#cb78-205" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Merge the DataFrames</span></span>
<span id="cb78-206"><a href="#cb78-206" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> pd.merge(forecast_sw, max_dates_per_year, on<span class="op">=</span>[<span class="st">'year'</span>, <span class="st">'report_date'</span>])</span>
<span id="cb78-207"><a href="#cb78-207" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract the month and assign seasons</span></span>
<span id="cb78-208"><a href="#cb78-208" aria-hidden="true" tabindex="-1"></a>        result[<span class="st">'month'</span>] <span class="op">=</span> result[<span class="st">'report_date'</span>].dt.month</span>
<span id="cb78-209"><a href="#cb78-209" aria-hidden="true" tabindex="-1"></a>        result[<span class="st">'season'</span>] <span class="op">=</span> result[<span class="st">'month'</span>].<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">'spring'</span> <span class="cf">if</span> <span class="dv">4</span> <span class="op">&lt;=</span> x <span class="op">&lt;</span> <span class="dv">6</span> <span class="cf">else</span> <span class="st">'summer'</span>)</span>
<span id="cb78-210"><a href="#cb78-210" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Assign values to the new columns based on the season</span></span>
<span id="cb78-211"><a href="#cb78-211" aria-hidden="true" tabindex="-1"></a>        result[<span class="st">'predicted_spring_anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[<span class="st">'npp_predict_clim'</span>] <span class="cf">if</span> row[<span class="st">'season'</span>] <span class="op">==</span> <span class="st">'spring'</span> <span class="cf">else</span> <span class="va">None</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb78-212"><a href="#cb78-212" aria-hidden="true" tabindex="-1"></a>        result[<span class="st">'predicted_summer_anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[<span class="st">'npp_predict_clim'</span>] <span class="cf">if</span> row[<span class="st">'season'</span>] <span class="op">==</span> <span class="st">'summer'</span> <span class="cf">else</span> <span class="va">None</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb78-213"><a href="#cb78-213" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Filter out years from hist_sw that are also present in forecast_sw</span></span>
<span id="cb78-214"><a href="#cb78-214" aria-hidden="true" tabindex="-1"></a>        forecast_years <span class="op">=</span> forecast_sw[<span class="st">'report_date'</span>].dt.year.unique()</span>
<span id="cb78-215"><a href="#cb78-215" aria-hidden="true" tabindex="-1"></a>        hist_sw <span class="op">=</span> hist_sw[<span class="op">~</span>hist_sw[<span class="st">'year'</span>].isin(forecast_years)]</span>
<span id="cb78-216"><a href="#cb78-216" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Select the specified columns</span></span>
<span id="cb78-217"><a href="#cb78-217" aria-hidden="true" tabindex="-1"></a>        selected_columns_hist <span class="op">=</span> hist_sw[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"predicted_spring_anpp_lbs_ac"</span>, <span class="st">"predicted_summer_anpp_lbs_ac"</span>]]</span>
<span id="cb78-218"><a href="#cb78-218" aria-hidden="true" tabindex="-1"></a>        selected_columns_forecast <span class="op">=</span> result[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"predicted_spring_anpp_lbs_ac"</span>, <span class="st">"predicted_summer_anpp_lbs_ac"</span>]]</span>
<span id="cb78-219"><a href="#cb78-219" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Group and merge</span></span>
<span id="cb78-220"><a href="#cb78-220" aria-hidden="true" tabindex="-1"></a>        merged_selected_columns_forecast <span class="op">=</span> selected_columns_forecast.groupby([<span class="st">'gridid'</span>, <span class="st">'year'</span>], as_index<span class="op">=</span><span class="va">False</span>).first()</span>
<span id="cb78-221"><a href="#cb78-221" aria-hidden="true" tabindex="-1"></a>        hist_sw <span class="op">=</span> pd.concat([selected_columns_hist, merged_selected_columns_forecast], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb78-222"><a href="#cb78-222" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store updated historical dataset for the next iteration</span></span>
<span id="cb78-223"><a href="#cb78-223" aria-hidden="true" tabindex="-1"></a>        df_to_s3_csv(hist_sw, bucket_name, key_path_sw_hist_read)</span>
<span id="cb78-224"><a href="#cb78-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-225"><a href="#cb78-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-226"><a href="#cb78-226" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Apply updates for GP ------------------#</span></span>
<span id="cb78-227"><a href="#cb78-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-228"><a href="#cb78-228" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> grasscast_forecast_gp <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb78-229"><a href="#cb78-229" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Updating GP data..."</span>)</span>
<span id="cb78-230"><a href="#cb78-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-231"><a href="#cb78-231" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add new climate related variables to the forecast dataset</span></span>
<span id="cb78-232"><a href="#cb78-232" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Merge forecast data with grid based on Id</span></span>
<span id="cb78-233"><a href="#cb78-233" aria-hidden="true" tabindex="-1"></a>        grasscast_forecast_gp_clim <span class="op">=</span> pd.merge(grasscast_forecast_gp, </span>
<span id="cb78-234"><a href="#cb78-234" aria-hidden="true" tabindex="-1"></a>                                            seasprcp_grid[[<span class="st">'gridid'</span>, <span class="st">'cat'</span>, <span class="st">'prob'</span>]], </span>
<span id="cb78-235"><a href="#cb78-235" aria-hidden="true" tabindex="-1"></a>                                            left_on<span class="op">=</span><span class="st">'gridid'</span>, right_on<span class="op">=</span><span class="st">'gridid'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb78-236"><a href="#cb78-236" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply function to calculate ANPP based on climate outlook to SW DataFrame</span></span>
<span id="cb78-237"><a href="#cb78-237" aria-hidden="true" tabindex="-1"></a>        grasscast_forecast_gp_clim[<span class="st">'npp_predict_clim'</span>] <span class="op">=</span> grasscast_forecast_gp_clim.<span class="bu">apply</span>(calculate_NPP_predict_clim, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb78-238"><a href="#cb78-238" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb78-239"><a href="#cb78-239" aria-hidden="true" tabindex="-1"></a>        <span class="co"># GP and SW grids overlap, so we need to remove the overlapping grids from the GP dataset which is the less informative (only one seasonal forecast)</span></span>
<span id="cb78-240"><a href="#cb78-240" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Read in overlapping grid ids</span></span>
<span id="cb78-241"><a href="#cb78-241" aria-hidden="true" tabindex="-1"></a>        overlapping_ids <span class="op">=</span> read_json_from_s3(bucket_name, key_path_overlapping_gridids_read)</span>
<span id="cb78-242"><a href="#cb78-242" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert the 'gridid' in overlapping_ids to a set for faster lookup</span></span>
<span id="cb78-243"><a href="#cb78-243" aria-hidden="true" tabindex="-1"></a>        overlapping_ids_set <span class="op">=</span> <span class="bu">set</span>(overlapping_ids[<span class="st">'gridid'</span>])</span>
<span id="cb78-244"><a href="#cb78-244" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a boolean index for rows in combined_df where 'gridid' is not in overlapping_ids_set</span></span>
<span id="cb78-245"><a href="#cb78-245" aria-hidden="true" tabindex="-1"></a>        non_overlapping_index <span class="op">=</span> <span class="op">~</span>grasscast_forecast_gp_clim[<span class="st">'gridid'</span>].isin(overlapping_ids_set)</span>
<span id="cb78-246"><a href="#cb78-246" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Filter the combined_df using this index</span></span>
<span id="cb78-247"><a href="#cb78-247" aria-hidden="true" tabindex="-1"></a>        grasscast_forecast_gp_clim <span class="op">=</span> grasscast_forecast_gp_clim[non_overlapping_index]</span>
<span id="cb78-248"><a href="#cb78-248" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store the updated forecast dataset to be used in the following iteration to pull updated data from GrassCast</span></span>
<span id="cb78-249"><a href="#cb78-249" aria-hidden="true" tabindex="-1"></a>        df_to_s3_csv(grasscast_forecast_gp_clim, bucket_name, key_path_gp_forecast_read)</span>
<span id="cb78-250"><a href="#cb78-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-251"><a href="#cb78-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-252"><a href="#cb78-252" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update last record on the historical dataset based on new forecast data</span></span>
<span id="cb78-253"><a href="#cb78-253" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Load last available historical data</span></span>
<span id="cb78-254"><a href="#cb78-254" aria-hidden="true" tabindex="-1"></a>        hist_gp <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_gp_hist_read)</span>
<span id="cb78-255"><a href="#cb78-255" aria-hidden="true" tabindex="-1"></a>        forecast_gp <span class="op">=</span> grasscast_forecast_gp_clim</span>
<span id="cb78-256"><a href="#cb78-256" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert the 'Date' column to datetime if it's not</span></span>
<span id="cb78-257"><a href="#cb78-257" aria-hidden="true" tabindex="-1"></a>        forecast_gp[<span class="st">'report_date'</span>] <span class="op">=</span> pd.to_datetime(forecast_gp[<span class="st">'report_date'</span>])</span>
<span id="cb78-258"><a href="#cb78-258" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Filter the dataframe for the last day of the year</span></span>
<span id="cb78-259"><a href="#cb78-259" aria-hidden="true" tabindex="-1"></a>        max_dates_per_year <span class="op">=</span> forecast_gp.groupby(<span class="st">'year'</span>)[<span class="st">'report_date'</span>].<span class="bu">max</span>()</span>
<span id="cb78-260"><a href="#cb78-260" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Merge the DataFrames</span></span>
<span id="cb78-261"><a href="#cb78-261" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> pd.merge(forecast_gp, max_dates_per_year, on<span class="op">=</span>[<span class="st">'year'</span>, <span class="st">'report_date'</span>])</span>
<span id="cb78-262"><a href="#cb78-262" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Assign the value from npp_predict_clim to anpp_lbs_ac or predicted_summer_anpp_lbs_ac</span></span>
<span id="cb78-263"><a href="#cb78-263" aria-hidden="true" tabindex="-1"></a>        result[<span class="st">'anpp_lbs_ac'</span>] <span class="op">=</span> result.<span class="bu">apply</span>(<span class="kw">lambda</span> row: row[<span class="st">'npp_predict_clim'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb78-264"><a href="#cb78-264" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Filter out years from hist_sw that are also present in forecast_sw</span></span>
<span id="cb78-265"><a href="#cb78-265" aria-hidden="true" tabindex="-1"></a>        forecast_years <span class="op">=</span> forecast_gp[<span class="st">'report_date'</span>].dt.year.unique()</span>
<span id="cb78-266"><a href="#cb78-266" aria-hidden="true" tabindex="-1"></a>        hist_gp <span class="op">=</span> hist_gp[<span class="op">~</span>hist_gp[<span class="st">'year'</span>].isin(forecast_years)]</span>
<span id="cb78-267"><a href="#cb78-267" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Select the specified columns from hist_grasscast_gp</span></span>
<span id="cb78-268"><a href="#cb78-268" aria-hidden="true" tabindex="-1"></a>        selected_columns_hist <span class="op">=</span> hist_gp[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"anpp_lbs_ac"</span>]]</span>
<span id="cb78-269"><a href="#cb78-269" aria-hidden="true" tabindex="-1"></a>        selected_columns_forecast <span class="op">=</span> result[[<span class="st">"gridid"</span>, <span class="st">"year"</span>, <span class="st">"anpp_lbs_ac"</span>]]</span>
<span id="cb78-270"><a href="#cb78-270" aria-hidden="true" tabindex="-1"></a>        merged_selected_columns_forecast <span class="op">=</span> selected_columns_forecast.groupby([<span class="st">'gridid'</span>, <span class="st">'year'</span>], as_index<span class="op">=</span><span class="va">False</span>).first()</span>
<span id="cb78-271"><a href="#cb78-271" aria-hidden="true" tabindex="-1"></a>        hist_gp <span class="op">=</span> pd.concat([selected_columns_hist, merged_selected_columns_forecast], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb78-272"><a href="#cb78-272" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store updated historical dataset for the next iteration</span></span>
<span id="cb78-273"><a href="#cb78-273" aria-hidden="true" tabindex="-1"></a>        df_to_s3_csv(hist_gp, bucket_name, key_path_gp_hist_read)</span>
<span id="cb78-274"><a href="#cb78-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-275"><a href="#cb78-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-276"><a href="#cb78-276" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------ Combine SW and GP dataframes ------------------#</span></span>
<span id="cb78-277"><a href="#cb78-277" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Combining SW and GP dataframes and preparing files..."</span>)</span>
<span id="cb78-278"><a href="#cb78-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-279"><a href="#cb78-279" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Read in files</span></span>
<span id="cb78-280"><a href="#cb78-280" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reloading the datasets to prevent potential problems associated when pulling GrassCast data from one of the regions</span></span>
<span id="cb78-281"><a href="#cb78-281" aria-hidden="true" tabindex="-1"></a>    hist_gp <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_gp_hist_read)</span>
<span id="cb78-282"><a href="#cb78-282" aria-hidden="true" tabindex="-1"></a>    hist_sw <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_sw_hist_read)</span>
<span id="cb78-283"><a href="#cb78-283" aria-hidden="true" tabindex="-1"></a>    forecast_gp <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_gp_forecast_read)</span>
<span id="cb78-284"><a href="#cb78-284" aria-hidden="true" tabindex="-1"></a>    forecast_sw <span class="op">=</span> read_csv_from_s3(bucket_name, key_path_sw_forecast_read)</span>
<span id="cb78-285"><a href="#cb78-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-286"><a href="#cb78-286" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Concatenate GP and SW and create the final datasets to be used in the APP</span></span>
<span id="cb78-287"><a href="#cb78-287" aria-hidden="true" tabindex="-1"></a>    df_hist <span class="op">=</span> pd.concat([hist_sw, hist_gp], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb78-288"><a href="#cb78-288" aria-hidden="true" tabindex="-1"></a>    df_forecast <span class="op">=</span> pd.concat([forecast_sw, forecast_gp], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb78-289"><a href="#cb78-289" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store the resulting datasets to be read in the APP</span></span>
<span id="cb78-290"><a href="#cb78-290" aria-hidden="true" tabindex="-1"></a>    df_to_s3_csv(df_hist, bucket_name, key_path_all_hist_read)</span>
<span id="cb78-291"><a href="#cb78-291" aria-hidden="true" tabindex="-1"></a>    df_to_s3_csv(df_forecast, bucket_name, key_path_all_forecast_read)</span>
<span id="cb78-292"><a href="#cb78-292" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Execution completed successfully."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="market-data-updates" class="level3">
<h3 class="anchored" data-anchor-id="market-data-updates">Market Data Updates</h3>
<p>As mentioned previously, most of the data displayed on the Markets page of the application is directly retrieved from the MMN API within the app. However, for the top market table and the weight vs.&nbsp;prices plot, the structure of the data pulled from the API cannot be used to generate the visualizations. Therefore, an additional Lambda function has been implemented to retrieve daily market auction cattle data, filter it, and restructure it to be compatible with the app.</p>
<p>Specifically, the code below, included in the respective Lambda function, retrieves all available auction livestock data for the markets listed in the JSON “markets_data_final,” which originates from the markets filtering process described in the “Listing available markets for Cattle and Hay” section. For those markets with data available from the last 30 days, the data is stored in S3 and made ready for use within the app.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lambda_funtion():</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> requests  <span class="co"># For making HTTP requests</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> json  <span class="co"># For handling JSON data</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> boto3  <span class="co"># AWS SDK for Python, allows Python scripts to use services like Amazon S3 and Amazon EC2</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> concurrent.futures <span class="im">import</span> ThreadPoolExecutor  <span class="co"># For parallel execution</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Constants</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    base_url <span class="op">=</span> <span class="st">"https://marsapi.ams.usda.gov"</span>  <span class="co"># Base URL for the marsapi</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>    api_key <span class="op">=</span> <span class="bu">open</span>(<span class="st">"foodsight-app/.mmn_api_token"</span>).read()   <span class="co"># API key for authentication with marsapi</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>    s3 <span class="op">=</span> boto3.client(<span class="st">'s3'</span>)  <span class="co"># Initializing Amazon S3 client</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>    bucket_name <span class="op">=</span> <span class="st">'foodsight-lambda'</span>  <span class="co"># Name of the S3 bucket</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>    key_path_read <span class="op">=</span> <span class="st">'market_data/markets_data_final.json'</span>  <span class="co"># Path to the JSON file in the S3 bucket</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to fetch data from marsapi</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_data_from_marsapi(endpoint):</span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> requests.Session() <span class="im">as</span> session:  <span class="co"># Creates a session to manage connections</span></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>            response <span class="op">=</span> session.get(base_url <span class="op">+</span> endpoint, auth<span class="op">=</span>(api_key, <span class="st">''</span>))  <span class="co"># Sends GET request</span></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Checks if the response status is 200 (OK)</span></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> response.status_code <span class="op">==</span> <span class="dv">200</span>:</span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> response.json()  <span class="co"># Returns JSON content of the response</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>                response.raise_for_status()  <span class="co"># Raises an exception if the response contains an error</span></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to fetch market data</span></span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fetch_data_for_market(market):</span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>        slug_id <span class="op">=</span> market[<span class="st">'slug_id'</span>]</span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>        market_name <span class="op">=</span> market[<span class="st">'market_location_name'</span>]</span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Fetching data for </span><span class="sc">{</span>market_name<span class="sc">}</span><span class="ss"> (Slug ID: </span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss">)..."</span>)</span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Endpoint to check data availability for the last 30 days</span></span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a>        endpoint_limit <span class="op">=</span> <span class="ss">f"/services/v1.2/reports/</span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss">/Details?lastDays=30&amp;market_type=Auction Livestock"</span></span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a>        data_limit <span class="op">=</span> get_data_from_marsapi(endpoint_limit)</span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-36"><a href="#cb79-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Checks if there's data for the last 30 days</span></span>
<span id="cb79-37"><a href="#cb79-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> data_limit <span class="kw">and</span> <span class="st">'results'</span> <span class="kw">in</span> data_limit <span class="kw">and</span> data_limit[<span class="st">'results'</span>]:</span>
<span id="cb79-38"><a href="#cb79-38" aria-hidden="true" tabindex="-1"></a>            lastDay <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Initializes day counter</span></span>
<span id="cb79-39"><a href="#cb79-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> lastDay <span class="op">&lt;=</span> <span class="dv">30</span>:  <span class="co"># Loop to search data day-by-day for the last 30 days</span></span>
<span id="cb79-40"><a href="#cb79-40" aria-hidden="true" tabindex="-1"></a>                endpoint <span class="op">=</span> <span class="ss">f"/services/v1.2/reports/</span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss">/Details?lastDays=</span><span class="sc">{</span>lastDay<span class="sc">}</span><span class="ss">&amp;market_type=Auction Livestock"</span></span>
<span id="cb79-41"><a href="#cb79-41" aria-hidden="true" tabindex="-1"></a>                data <span class="op">=</span> get_data_from_marsapi(endpoint)</span>
<span id="cb79-42"><a href="#cb79-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-43"><a href="#cb79-43" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Checks if data is available for the day</span></span>
<span id="cb79-44"><a href="#cb79-44" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> data <span class="kw">and</span> <span class="st">'results'</span> <span class="kw">in</span> data <span class="kw">and</span> data[<span class="st">'results'</span>]:</span>
<span id="cb79-45"><a href="#cb79-45" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"Data found for </span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss"> at lastDay=</span><span class="sc">{</span>lastDay<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-46"><a href="#cb79-46" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> data[<span class="st">'results'</span>]</span>
<span id="cb79-47"><a href="#cb79-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-48"><a href="#cb79-48" aria-hidden="true" tabindex="-1"></a>                <span class="co"># If no data found for the day, print a message and check the next day</span></span>
<span id="cb79-49"><a href="#cb79-49" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"No data found for </span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss"> at lastDay=</span><span class="sc">{</span>lastDay<span class="sc">}</span><span class="ss">. Trying next day..."</span>)</span>
<span id="cb79-50"><a href="#cb79-50" aria-hidden="true" tabindex="-1"></a>                lastDay <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb79-51"><a href="#cb79-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-52"><a href="#cb79-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If no data found for the last 30 days, print a message and move to the next market</span></span>
<span id="cb79-53"><a href="#cb79-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"No data found for </span><span class="sc">{</span>slug_id<span class="sc">}</span><span class="ss"> within the last 30 days. Moving to the next slug_id."</span>)</span>
<span id="cb79-54"><a href="#cb79-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb79-55"><a href="#cb79-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-56"><a href="#cb79-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to fetch data for all markets</span></span>
<span id="cb79-57"><a href="#cb79-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fetch_all_data(markets_list):</span>
<span id="cb79-58"><a href="#cb79-58" aria-hidden="true" tabindex="-1"></a>        all_data <span class="op">=</span> []</span>
<span id="cb79-59"><a href="#cb79-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-60"><a href="#cb79-60" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Parallel execution using ThreadPoolExecutor</span></span>
<span id="cb79-61"><a href="#cb79-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> ThreadPoolExecutor() <span class="im">as</span> executor:</span>
<span id="cb79-62"><a href="#cb79-62" aria-hidden="true" tabindex="-1"></a>            results <span class="op">=</span> <span class="bu">list</span>(executor.<span class="bu">map</span>(fetch_data_for_market, markets_list))</span>
<span id="cb79-63"><a href="#cb79-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-64"><a href="#cb79-64" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Aggregates all data</span></span>
<span id="cb79-65"><a href="#cb79-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> data <span class="kw">in</span> results:</span>
<span id="cb79-66"><a href="#cb79-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> data:</span>
<span id="cb79-67"><a href="#cb79-67" aria-hidden="true" tabindex="-1"></a>                all_data.extend(data)</span>
<span id="cb79-68"><a href="#cb79-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-69"><a href="#cb79-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> all_data</span>
<span id="cb79-70"><a href="#cb79-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-71"><a href="#cb79-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fetching market list from S3</span></span>
<span id="cb79-72"><a href="#cb79-72" aria-hidden="true" tabindex="-1"></a>    response <span class="op">=</span> s3.get_object(Bucket<span class="op">=</span>bucket_name, Key<span class="op">=</span>key_path_read)  <span class="co"># Fetches the object from the S3 bucket</span></span>
<span id="cb79-73"><a href="#cb79-73" aria-hidden="true" tabindex="-1"></a>    markets_list <span class="op">=</span> json.loads(response[<span class="st">'Body'</span>].read().decode(<span class="st">'utf-8'</span>))  <span class="co"># Decodes and loads the JSON data</span></span>
<span id="cb79-74"><a href="#cb79-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-75"><a href="#cb79-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fetches data for all markets</span></span>
<span id="cb79-76"><a href="#cb79-76" aria-hidden="true" tabindex="-1"></a>    last_market_data <span class="op">=</span> fetch_all_data(markets_list)</span>
<span id="cb79-77"><a href="#cb79-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-78"><a href="#cb79-78" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Converts the aggregated data to JSON and uploads to S3</span></span>
<span id="cb79-79"><a href="#cb79-79" aria-hidden="true" tabindex="-1"></a>    json_content <span class="op">=</span> json.dumps(last_market_data)</span>
<span id="cb79-80"><a href="#cb79-80" aria-hidden="true" tabindex="-1"></a>    json_bytes <span class="op">=</span> json_content.encode(<span class="st">'utf-8'</span>)</span>
<span id="cb79-81"><a href="#cb79-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-82"><a href="#cb79-82" aria-hidden="true" tabindex="-1"></a>    key_path_write <span class="op">=</span> <span class="st">'market_data/last_market_data.json'</span></span>
<span id="cb79-83"><a href="#cb79-83" aria-hidden="true" tabindex="-1"></a>    s3.put_object(Bucket<span class="op">=</span>bucket_name, Key<span class="op">=</span>key_path_write, Body<span class="op">=</span>json_bytes)</span>
<span id="cb79-84"><a href="#cb79-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Store data at: bucket </span><span class="sc">{</span>bucket_name<span class="sc">}</span><span class="ss">, key </span><span class="sc">{</span>key_path_write<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb79-85"><a href="#cb79-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-86"><a href="#cb79-86" aria-hidden="true" tabindex="-1"></a>        </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In contrast to the Forecast Lambdas, the simplicity in terms of required dependencies for this function has enabled it to be deployed directly from a zip file containing all the preinstalled dependencies. You can install it using the command provided in the “readme.txt” file.</p>
</section>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<p>FoodSight combines a range of resources from various sources, including government agencies and universities, into a user-friendly platform. This integration facilitates access to data, enhancing its representation, and providing basic analysis tools. Among these resources, the core components of the app include:</p>
<section id="productivity-forecast" class="level3">
<h3 class="anchored" data-anchor-id="productivity-forecast">Productivity Forecast</h3>
<p>The Grassland Productivity Forecast is a GrassCast product developed by the University of Nebraska-Lincoln, specifically designed for land managers and ranchers. This tool utilizes nearly 40 years of historical weather and vegetation data, combined with seasonal precipitation forecasts, to predict grassland productivity. It assesses whether productivity, measured in pounds per acre, is likely to be above-normal, near-normal, or below-normal for the upcoming season. GrassCast is updated bi-weekly during spring and summer, adjusting to the expected weather for that season, thus providing crucial insights for grazing management.</p>
<p>You can learn more about the project and access the forecast data in the form of static maps and CSV files at <a href="https://grasscast.unl.edu">GrassCast</a>.</p>
<p>To know what forecast scenario is more likely to occur, you can visit the <a href="https://www.cpc.ncep.noaa.gov/products/predictions/long_range/interactive/index.php">long-range precipitation outlooks provided by NOAA</a>.</p>
</section>
<section id="market-data-1" class="level3">
<h3 class="anchored" data-anchor-id="market-data-1">Market Data</h3>
<p><a href="https://www.ams.usda.gov/market-news">USDA Market News</a> provides essential resources for those interested in livestock market information. You can access detailed historical data and reports on sales, nominal prices, volumes, and market trends for various agricultural categories and commodities. This <a href="https://www.marketnews.usda.gov/mnp/ls-report-config?category=Calves">data is available for download</a> in .xls, .txt, .xml, and .pdf formats, covering records from 2000 to 2019 depending on the commodity. For the most recent data—2019 and onwards—, USDA provides free access to the <a href="https://mymarketnews.ams.usda.gov">My Market News API</a>. This API is a powerful tool for developers and analysts, offering customized market data feeds and integration capabilities for several systems or applications. These resources—feeding FoodSight’s markets page— are invaluable for stakeholders in the livestock industry, providing real-time and detailed market data to support buying, selling, and production decisions.</p>
</section>
<section id="decision-support-tool" class="level3">
<h3 class="anchored" data-anchor-id="decision-support-tool">Decision Support Tool</h3>
<p>Several farming and ranching decision support tools have been released and are publicly available online. For the FoodSight beta version, we explored the potential interest of users in combining insights from the forecast and market pages for informed ranching management decisions, especially during drought events. Therefore, we incorporated guidelines and suggestions derived from ‘Strategies for Beef Cattle Herds During Times of Drought’, a tool designed by Jeffrey E. Tranel, Rod Sharp, &amp; John Deering from the Department of Agriculture and Business Management at Colorado State University. The goal of this decision tool is to assist cow producers in comparing the financial implications of different management strategies during droughts when grazing forage is scarce.</p>
<p>See <a href="https://www.extension.colostate.edu">Strategies for Beef Cattle Herds During Times of Drought</a> for more information. Tool available in Excel format.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->



</body></html>